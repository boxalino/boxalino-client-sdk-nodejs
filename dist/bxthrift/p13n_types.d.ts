//
// Autogenerated by Thrift Compiler (0.10.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//


/**
 * Used for date facets
 */
declare enum DateRangeGap {
  SECOND = 1,
  MINUTE = 2,
  HOUR = 3,
  DAY = 4,
  WEEK = 5,
  MONTH = 6,
  YEAR = 7,
  DECADE = 8,
  CENTURY = 9,
}

/**
 * Whether facets should be order by population descending or by collation
 */
declare enum FacetSortOrder {
  POPULATION = 1,
  COLLATION = 2,
}

/**
 * Filter to be used in query. Note that type of generated filter depends on first non-null and non-empty value in order of preference. Values of lower priority are ignored:
 * stringValues!=null && simpleValues.size()>0 => simple match, prefix!=null => prefix match, hierarchy!=null && hierarchy.size()>0 => hierarchy filter, else range filter
 * 
 * <dl>
 * <dt>negative</dt>
 * <dd>whether the filter is negative (boolean NOT)</dd>
 * 
 * <dt>fieldName</dt>
 * <dd>field name to apply filter to</dd>
 * 
 * <dt>stringValues</dt>
 * <dd>values for simple match</dd>
 * 
 * <dt>prefix</dt>
 * <dd>prefix match</dd>
 * 
 * <dt>hierarchyId</dt>
 * <dd>hierarchy filter - when corresponding hierarchical field has encoded id</dd>
 * 
 * <dt>hierarchy</dt>
 * <dd>hierarchy filter - for example categories path in top-down order</dd>
 * 
 * <dt>rangeFrom</dt>
 * <dd>lower bound for range filter</dd>
 * 
 * <dt>rangeFromInclusive</dt>
 * <dd>whether the lower bound is inclusive</dd>
 * 
 * <dt>rangeTo</dt>
 * <dd>upper bound for range filter</dd>
 * 
 * <dt>rangeToInclusive</dt>
 * <dd>whether the upper bound is inclusive</dd>
 * </dl>
 */
declare class Filter {
  negative: boolean;
  fieldName: string;
  stringValues: string[];
  prefix: string;
  hierarchyId: string;
  hierarchy: string[];
  rangeFrom: string;
  rangeFromInclusive: boolean;
  rangeTo: string;
  rangeToInclusive: boolean;

  constructor(args?: { negative: boolean; fieldName: string; stringValues: string[]; prefix: string; hierarchyId: string; hierarchy: string[]; rangeFrom: string; rangeFromInclusive: boolean; rangeTo: string; rangeToInclusive: boolean; });
}

/**
 * <dl>
 * <dt>stringValue</dt>
 * <dd>corresponding value of the facet</dd>
 * 
 * <dt>rangeFromInclusive</dt>
 * <dd>if range facets lower bound (inclusive)</dd>
 * 
 * <dt>rangeToExclusive</dt>
 * <dd>if range facets upper bound (inclusive)</dd>
 * 
 * <dt>hitCount</dt>
 * <dd>number of hits found</dd>
 * 
 * <dt>hierarchyId</dt>
 * <dd>id of hierarchy if corresponding field is hierarchical</dd>
 * 
 * <dt>hierarchy</dt>
 * <dd>hierarchy if corresponding field is hierarchical</dd>
 * 
 * <dt>selected</dt>
 * <dd>whether the facet value has been selected in corresponding FacetRequest</dd>
 * </dl>
 */
declare class FacetValue {
  stringValue: string;
  rangeFromInclusive: string;
  rangeToExclusive: string;
  hitCount: number;
  hierarchyId: string;
  hierarchy: string[];
  selected: boolean;

  constructor(args?: { stringValue: string; rangeFromInclusive: string; rangeToExclusive: string; hitCount: number; hierarchyId: string; hierarchy: string[]; selected: boolean; });
}

/**
 * <dl>
 * <dt>fieldName</dt>
 * <dd>name of the field to get facet for</dd>
 * 
 * <dt>numerical</dt>
 * <dd>whether the facet is numerical</dd>
 * 
 * <dt>range</dt>
 * <dd>whether the facet is range facet</dd>
 * 
 * <dt>maxCount</dt>
 * <dd>maximum number of facets to return by given order, -1 for all of them</dd>
 * 
 * <dt>minPopulation</dt>
 * <dd>minimum facet population to return</dd>
 * 
 * <dt>dateRangeGap</dt>
 * <dd>if the corresponding field is date then the gap to be used for facet</dd>
 * 
 * <dt>sortOrder</dt>
 * <dd>sort order</dd>
 * 
 * <dt>sortAscending</dt>
 * <dd>whether the sort should be done ascending</dd>
 * 
 * <dt>selectedValues</dt>
 * <dd>values selected from the facet.</dd>
 * <dd>Note that results will be filtered by these values, but the corresponding
 * FacetResponse is as if this filter was not applied</dd>
 * 
 * <dt>andSelectedValues</dt>
 * <dd>whether selectedValues should be considered in AND logic, meaning filter
 * out those that don't contain ALL selected values - default is OR - include
 * those contianing any of selectedValue</dd>
 * 
 * <dt>boundsOnly</dt>
 * <dd>only affects numeric range facets. will always return one FacetValue with rangeFromInclusive and rangeToExclusive
 * set according to the actual minimum and maximum value</dd>
 * </dl>
 */
declare class FacetRequest {
  fieldName: string;
  numerical: boolean;
  range: boolean;
  maxCount: number;
  minPopulation: number;
  dateRangeGap: DateRangeGap;
  sortOrder: FacetSortOrder;
  sortAscending: boolean;
  selectedValues: FacetValue[];
  andSelectedValues: boolean;
  boundsOnly: boolean;
  evaluate: boolean;
  display: string;
  extraInfo: { [k: string]: string; };

  constructor(args?: { fieldName: string; numerical: boolean; range: boolean; maxCount: number; minPopulation: number; dateRangeGap: DateRangeGap; sortOrder: FacetSortOrder; sortAscending: boolean; selectedValues: FacetValue[]; andSelectedValues: boolean; boundsOnly: boolean; evaluate: boolean; display: string; extraInfo: { [k: string]: string; }; });
}

/**
 * field to be used for sorting
 */
declare class SortField {
  fieldName: string;
  reverse: boolean;

  constructor(args?: { fieldName: string; reverse: boolean; });
}

/**
 * <dl>
 * <dt>indexId</dt>
 * <dd>indexId to be used for search</dd>
 * 
 * <dt>language</dt>
 * <dd>language for localization</dd>
 * 
 * <dt>queryText</dt>
 * <dd>main search query</dd>
 * 
 * <dt>filters</dt>
 * <dd>list of filters to apply</dd>
 * 
 * <dt>orFilters</dt>
 * <dd>whether boolean OR should be aplied to the given list of filters if false
 * boolean AND will be applied</dd>
 * 
 * <dt>facetRequests</dt>
 * <dd>list of facets to be returned</dd>
 * 
 * <dt>sortFields</dt>
 * <dd>optional list of sort fields for hardcoded sorting. If not given,
 * relevance sort order will be used</dd>
 * 
 * <dt>offset</dt>
 * <dd>from which hit to return result</dd>
 * 
 * <dt>hitCount</dt>
 * <dd>how many hits to return</dd>
 * 
 * <dt>returnFields</dt>
 * <dd>which index fields to be returned</dd>
 * 
 * <dt>groupBy</dt>
 * <dd>field name of the field to do grouping by</dd>
 * 
 * <dt>groupFacets</dt>
 * <dd>whether facets counts should contain number of groups</dd>
 * 
 * <dt>groupItemsCount</dt>
 * <dd>how many hits in each group to return</dd>
 * 
 * <dt>groupItemsSort</dt>
 * <dd>how to sort items within the group, default is score</dd>
 * 
 * <dt>groupItemsSortAscending</dt>
 * <dd>whether to sort items within the group ascending</dd>
 * 
 * <dt>hitsGroupsAsHits</dt>
 * <dd>if true, will return hitsGroups as hits in the response</dd>
 * </dl>
 */
declare class SimpleSearchQuery {
  indexId: string;
  language: string;
  queryText: string;
  filters: Filter[];
  orFilters: boolean;
  facetRequests: FacetRequest[];
  sortFields: SortField[];
  offset: number;
  hitCount: number;
  returnFields: string[];
  groupBy: string;
  groupFacets: boolean;
  groupItemsCount: number;
  groupItemsSort: string;
  groupItemsSortAscending: boolean;
  hitsGroupsAsHits: boolean;

  constructor(args?: { indexId: string; language: string; queryText: string; filters: Filter[]; orFilters: boolean; facetRequests: FacetRequest[]; sortFields: SortField[]; offset: number; hitCount: number; returnFields: string[]; groupBy: string; groupFacets: boolean; groupItemsCount: number; groupItemsSort: string; groupItemsSortAscending: boolean; hitsGroupsAsHits: boolean; });
}

/**
 * <dl>
 * <dt>indexId</dt>
 * <dd>id of the index to fetch context item data from</dd>
 * 
 * <dt>fieldName</dt>
 * <dd>the field name of the item's unique identifier within the items index</dd>
 * <dd>for example: 'sku' for items 'products'</dd>
 * 
 * <dt>contextItemId</dt>
 * <dd>actual item's identifier</dd>
 * <dd>for example: actual sku of the product</dd>
 * 
 * <dt>role</dt>
 * <dd>role of the item within the context, used to address the item in the
 * recommendation script.</dd>
 * <dd>for example: 'main product' for recommendations within product detail
 * page</dd>
 * </dl>
 */
declare class ContextItem {
  indexId: string;
  fieldName: string;
  contextItemId: string;
  role: string;

  constructor(args?: { indexId: string; fieldName: string; contextItemId: string; role: string; });
}

/**
 * <dl>
 * <dt>choiceId</dt>
 * <dd>personalization choice identificator</dd>
 * 
 * <dt>simpleSearchQuery</dt>
 * <dd>search query in a case of recommendation and search inquiries</dd>
 * 
 * <dt>contextItems</dt>
 * <dd>context items for recommendations</dd>
 * 
 * <dt>minHitCount</dt>
 * <dd>minimal hit count to return for recommendations.</dd>
 * <dd>if higher priority recommendation strategy yields less results, next
 * strategy is tried</dd>
 * 
 * <dt>excludeVariantIds</dt>
 * <dd>set of variantIds to be excluded from result, has no effect if null or empty</dd>
 * 
 * <dt>includeVariantIds</dt>
 * <dd>set of variantIds to be included in the result, has no effect if null or empty</dd>
 * 
 * <dt>scope</dt>
 * <dd>choice source to be used</dd>
 * 
 * <dt>withRelaxation</dt>
 * <dd>if search relaxation should be used</dd>
 * </dl>
 */
declare class ChoiceInquiry {
  choiceId: string;
  simpleSearchQuery: SimpleSearchQuery;
  contextItems: ContextItem[];
  minHitCount: number;
  excludeVariantIds: string[];
  scope: string;
  withRelaxation: boolean;
  withSemanticFiltering: boolean;
  includeVariantIds: string[];

  constructor(args?: { choiceId: string; simpleSearchQuery: SimpleSearchQuery; contextItems: ContextItem[]; minHitCount: number; excludeVariantIds: string[]; scope: string; withRelaxation: boolean; withSemanticFiltering: boolean; includeVariantIds: string[]; });
}

/**
 * parameters of request context. Usually browser, platform, etc.
 */
declare class RequestContext {
  parameters: { [k: string]: string[]; };

  constructor(args?: { parameters: { [k: string]: string[]; }; });
}

/**
 * unique identifier of the customer
 */
declare class UserRecord {
  username: string;
  apiKey: string;
  apiSecret: string;

  constructor(args?: { username: string; apiKey: string; apiSecret: string; });
}

/**
 * <dl>
 * <dt>profileId</dt>
 * <dd>profile (visitor) identificator</dd>
 * 
 * <dt>inquiries</dt>
 * <dd>list of inquiries to be executed sequentially.</dd>
 * <dd>Inquiries with higher index may depend from those with lower index.</dd>
 * 
 * <dt>requestContext</dt>
 * <dd>context of the request</dd>
 * </dl>
 */
declare class ChoiceRequest {
  userRecord: UserRecord;
  profileId: string;
  inquiries: ChoiceInquiry[];
  requestContext: RequestContext;

  constructor(args?: { userRecord: UserRecord; profileId: string; inquiries: ChoiceInquiry[]; requestContext: RequestContext; });
}

declare class ChoiceRequestBundle {
  requests: ChoiceRequest[];

  constructor(args?: { requests: ChoiceRequest[]; });
}

declare class ChoiceResponseBundle {
  responses: ChoiceResponse[];

  constructor(args?: { responses: ChoiceResponse[]; });
}

/**
 * <dl>
 * <dt>fieldName</dt>
 * <dd>name of the facet field</dd>
 * 
 * <dt>values</dt>
 * <dd>list of facet values</dd>
 * </dl>
 */
declare class FacetResponse {
  fieldName: string;
  values: FacetValue[];
  evaluate: boolean;
  display: string;
  numerical: boolean;
  range: boolean;
  sortOrder: FacetSortOrder;
  sortAscending: boolean;
  andSelectedValues: boolean;
  boundsOnly: boolean;
  extraInfo: { [k: string]: string; };

  constructor(args?: { fieldName: string; values: FacetValue[]; evaluate: boolean; display: string; numerical: boolean; range: boolean; sortOrder: FacetSortOrder; sortAscending: boolean; andSelectedValues: boolean; boundsOnly: boolean; extraInfo: { [k: string]: string; }; });
}

/**
 * item found
 * 
 * <dl>
 * <dt>values</dt>
 * <dd>map containing name of the field and list of values as strings</dd>
 * <dd>if index contains no value for a field, empty array will be returned.</dd>
 * 
 * <dt>score</dt>
 * <dd>index score of the hit</dd>
 * 
 * <dt>scenarioId</dt>
 * <dd>source scenarioId in case of mixed recommendations modes</dd>
 * </dl>
 */
declare class Hit {
  values: { [k: string]: string[]; };
  score: number;
  scenarioId: string;

  constructor(args?: { values: { [k: string]: string[]; }; score: number; scenarioId: string; });
}

/**
 * grouped item found
 * 
 * <dl>
 * <dt>groupValue</dt>
 * <dd>value of the groupBy field</dd>
 * 
 * <dt>totalHitCount</dt>
 * <dd>total hits count within the group</dd>
 * 
 * <dt>hits</dt>
 * <dd>group hits</dd>
 * </dl>
 */
declare class HitsGroup {
  groupValue: string;
  totalHitCount: number;
  hits: Hit[];

  constructor(args?: { groupValue: string; totalHitCount: number; hits: Hit[]; });
}

/**
 * <dl>
 * <dt>hits</dt>
 * <dd>list of hits found for given SimpleSearchQuery</dd>
 * 
 * <dt>facetResponses</dt>
 * <dd>list of requested facets or null if none requested</dd>
 * 
 * <dt>totalHitCount</dt>
 * <dd>total number of hits; -1 in case of mixed recommendation strategy</dd>
 * 
 * <dt>queryText</dt>
 * <dd>relaxation query text for relaxation results or requested queryText for a
 * regular SearchResult</dd>
 * 
 * <dt>hitsGroups</dt>
 * <dd>grouped hits; not null when corresponding SimplSearchQuery has
 * groupBy!=null </dd>
 * </dl>
 */
declare class SearchResult {
  hits: Hit[];
  facetResponses: FacetResponse[];
  totalHitCount: number;
  queryText: string;
  hitsGroups: HitsGroup[];

  constructor(args?: { hits: Hit[]; facetResponses: FacetResponse[]; totalHitCount: number; queryText: string; hitsGroups: HitsGroup[]; });
}

declare class SearchRelaxation {
  suggestionsResults: SearchResult[];
  subphrasesResults: SearchResult[];

  constructor(args?: { suggestionsResults: SearchResult[]; subphrasesResults: SearchResult[]; });
}

/**
 * <dl>
 * <dt>variantId</dt>
 * <dd>id of the personalized variant</dd>
 * 
 * <dt>scenarioId</dt>
 * <dd>scenario identificator used to produce recommendation result or search
 * result personalization</dd>
 * 
 * <dt>searchResult</dt>
 * <dd>result of the search request for recommendations and search requests</dd>
 * 
 * <dt>searchResultTitle</dt>
 * <dd>recommendation's result title localized in language requested in
 * corresponding SimpleSearchQuery</dd>
 * 
 * <dt>searchRelaxation</dt>
 * <dd>When the service considers queryText invalid, it will evaluate and return
 * relaxations if it is requested in corresponding ChoiceInquiry and if
 * relaxations could be found.</dd>
 * <dd>Note that original query still could yield some results; it is up to the
 * client to decide whether searchRelaxations should be used (with displaying
 * appropriate message) or not.</dd>
 * </dl>
 */
declare class Variant {
  variantId: string;
  scenarioId: string;
  searchResult: SearchResult;
  searchResultTitle: string;
  searchRelaxation: SearchRelaxation;
  semanticFilteringResults: SearchResult[];
  extraInfo: { [k: string]: string; };

  constructor(args?: { variantId: string; scenarioId: string; searchResult: SearchResult; searchResultTitle: string; searchRelaxation: SearchRelaxation; semanticFilteringResults: SearchResult[]; extraInfo: { [k: string]: string; }; });
}

/**
 * list of personalized variants. Item's index corresponds to the index of the
 * ChoiceInquiry
 */
declare class ChoiceResponse {
  variants: Variant[];

  constructor(args?: { variants: Variant[]; });
}

declare class ProfilePropertyValue {
  profileId: string;
  propertyName: string;
  propertyValue: string;
  confidence: number;

  constructor(args?: { profileId: string; propertyName: string; propertyValue: string; confidence: number; });
}

declare class ProfileContext {
  profileId: string;
  requestContext: RequestContext;

  constructor(args?: { profileId: string; requestContext: RequestContext; });
}

/**
 * <dl>
 * <dt>choiceInquiry</dt>
 * <dd><b>deprecated</b> - use choiceInquiries instead.</dd>
 * <dd>If choiceInquiries is given this field will be ignored</dd>
 * 
 * <dt>choiceInquiries</dt>
 * <dd>list of ChoiceInquiries to be executed sequentially.</dd>
 * <dd>Note that list items can depend of items before in list</dd>
 * 
 * <dt>requestContext</dt>
 * <dd><b>deprecated</b> - use profileContexts instead.</dd>
 * 
 * <dt>profileIds</dt>
 * <dd><b>deprecated</b> - use profileContexts instead.</dd>
 * </dl>
 */
declare class BatchChoiceRequest {
  userRecord: UserRecord;
  choiceInquiry: ChoiceInquiry;
  requestContext: RequestContext;
  profileIds: string[];
  choiceInquiries: ChoiceInquiry[];
  profileContexts: ProfileContext[];

  constructor(args?: { userRecord: UserRecord; choiceInquiry: ChoiceInquiry; requestContext: RequestContext; profileIds: string[]; choiceInquiries: ChoiceInquiry[]; profileContexts: ProfileContext[]; });
}

/**
 * <dl>
 * <dt>variants</dt>
 * <dd><b>deprecated</b> - contains non-null value only if
 * corresponding BatchChoiceRequest had only one ChoiceInquiry</dd>
 * 
 * <dt>selectedVariants</dt>
 * <dd>outer list corresponds to profileIds given in BatchChoiceRequest, while
 * inner list corresponds to list of ChoiceInquiries from BatchChoiceRequest</dd>
 * </dl>
 */
declare class BatchChoiceResponse {
  variants: Variant[];
  selectedVariants: Variant[][];

  constructor(args?: { variants: Variant[]; selectedVariants: Variant[][]; });
}

declare class AutocompleteHit {
  suggestion: string;
  highlighted: string;
  searchResult: SearchResult;
  score: number;

  constructor(args?: { suggestion: string; highlighted: string; searchResult: SearchResult; score: number; });
}

declare class AutocompleteQuery {
  indexId: string;
  language: string;
  queryText: string;
  suggestionsHitCount: number;
  highlight: boolean;
  highlightPre: string;
  highlightPost: string;

  constructor(args?: { indexId: string; language: string; queryText: string; suggestionsHitCount: number; highlight: boolean; highlightPre: string; highlightPost: string; });
}

declare class AutocompleteRequest {
  userRecord: UserRecord;
  scope: string;
  choiceId: string;
  profileId: string;
  requestContext: RequestContext;
  excludeVariantIds: string[];
  autocompleteQuery: AutocompleteQuery;
  searchChoiceId: string;
  searchQuery: SimpleSearchQuery;
  includeVariantIds: string[];
  propertyQueries: PropertyQuery[];

  constructor(args?: { userRecord: UserRecord; scope: string; choiceId: string; profileId: string; requestContext: RequestContext; excludeVariantIds: string[]; autocompleteQuery: AutocompleteQuery; searchChoiceId: string; searchQuery: SimpleSearchQuery; includeVariantIds: string[]; propertyQueries: PropertyQuery[]; });
}

declare class PropertyQuery {
  name: string;
  hitCount: number;
  evaluateTotal: boolean;

  constructor(args?: { name: string; hitCount: number; evaluateTotal: boolean; });
}

declare class PropertyResult {
  hits: PropertyHit[];
  name: string;

  constructor(args?: { hits: PropertyHit[]; name: string; });
}

declare class PropertyHit {
  value: string;
  label: string;
  totalHitCount: number;

  constructor(args?: { value: string; label: string; totalHitCount: number; });
}

declare class AutocompleteResponse {
  hits: AutocompleteHit[];
  prefixSearchResult: SearchResult;
  propertyResults: PropertyResult[];
  extraInfo: { [k: string]: string; };

  constructor(args?: { hits: AutocompleteHit[]; prefixSearchResult: SearchResult; propertyResults: PropertyResult[]; extraInfo: { [k: string]: string; }; });
}

declare class AutocompleteRequestBundle {
  requests: AutocompleteRequest[];

  constructor(args?: { requests: AutocompleteRequest[]; });
}

declare class AutocompleteResponseBundle {
  responses: AutocompleteResponse[];

  constructor(args?: { responses: AutocompleteResponse[]; });
}

/**
 * Request object for changing the choice, that is changing possible variants
 * or their random distribution
 */
declare class ChoiceUpdateRequest {
  userRecord: UserRecord;
  choiceId: string;
  variantIds: { [k: string]: number; };

  constructor(args?: { userRecord: UserRecord; choiceId: string; variantIds: { [k: string]: number; }; });
}

/**
 * Server response for one ChoiceUpdateRequest
 */
declare class ChoiceUpdateResponse {
  choiceId: string;

  constructor(args?: { choiceId: string; });
}

declare class P13nServiceException extends Thrift.TException {
  message: string;

  constructor(args?: { message: string; });
}
