"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var comparators_1 = require("../functional/comparators");
var global_1 = require("../iterator/global");
var modifiers_1 = require("./modifiers");
/* =========================================================
    POPLAR-HEAP (https://github.com/Morwenn/poplar-heap)
        - PUSH
        - POP
        - SORT
        - BACKGROUND
============================================================
    PUSH
--------------------------------------------------------- */
/**
 * Make a heap.
 *
 * @param first Random access iteartor of the first position.
 * @param last Random access iterator of the last position.
 * @param comp A binary function predicates *x* element would be placed before *y*. When returns `true`, then *x* precedes *y*. Default is {@link less}.
 */
function make_heap(first, last, comp) {
    if (comp === void 0) { comp = comparators_1.less; }
    for (var it = first; !it.equals(last); it = it.next())
        push_heap(first, it, comp);
    push_heap(first, last, comp);
}
exports.make_heap = make_heap;
/**
 * Push an element into heap.
 *
 * @param first Random access iteartor of the first position.
 * @param last Random access iterator of the last position.
 * @param comp A binary function predicates *x* element would be placed before *y*. When returns `true`, then *x* precedes *y*. Default is {@link less}.
 */
function push_heap(first, last, comp) {
    if (comp === void 0) { comp = comparators_1.less; }
    var size = global_1.distance(first, last);
    // COMPUTE LAST_POLOR_SIZE
    var last_poplar_size = _Hyper_floor(size + 1) - 1;
    while (size - last_poplar_size !== 0) {
        size -= last_poplar_size;
        last_poplar_size = _Hyper_floor(size + 1) - 1;
    }
    // DO SIFT
    _Sift(last.advance(-last_poplar_size), last_poplar_size, comp);
}
exports.push_heap = push_heap;
/* ---------------------------------------------------------
    POP
--------------------------------------------------------- */
/**
 * Pop an element from heap.
 *
 * @param first Random access iteartor of the first position.
 * @param last Random access iterator of the last position.
 * @param comp A binary function predicates *x* element would be placed before *y*. When returns `true`, then *x* precedes *y*. Default is {@link less}.
 */
function pop_heap(first, last, comp) {
    if (comp === void 0) { comp = comparators_1.less; }
    var size = global_1.distance(first, last);
    var poplar_size = _Hyper_floor(size + 1) - 1;
    var last_root = last.prev();
    var bigger = last_root;
    var bigger_size = poplar_size;
    // Look for the bigger poplar root
    var it = first;
    while (true) {
        var root = it.advance(poplar_size - 1);
        if (root.equals(last_root))
            break;
        else if (comp(bigger.value, root.value)) {
            bigger = root;
            bigger_size = poplar_size;
        }
        it = root.next();
        size -= poplar_size;
        poplar_size = _Hyper_floor(size + 1) - 1;
    }
    // Swap & sift if needed
    if (bigger !== last_root) {
        modifiers_1.iter_swap(bigger, last_root);
        _Sift(bigger.advance(-bigger_size + 1), bigger_size, comp);
    }
}
exports.pop_heap = pop_heap;
/* ---------------------------------------------------------
    SORT
--------------------------------------------------------- */
/**
 * Test whether a range is heap.
 *
 * @param first Bi-directional iteartor of the first position.
 * @param last Bi-directional iterator of the last position.
 * @param comp A binary function predicates *x* element would be placed before *y*. When returns `true`, then *x* precedes *y*. Default is {@link less}.
 *
 * @return Whether the range is heap.
 */
function is_heap(first, last, comp) {
    if (comp === void 0) { comp = comparators_1.less; }
    var it = is_heap_until(first, last, comp);
    return it.equals(last);
}
exports.is_heap = is_heap;
/**
 * Find the first element not in heap order.
 *
 * @param first Bi-directional iteartor of the first position.
 * @param last Bi-directional iterator of the last position.
 * @param comp A binary function predicates *x* element would be placed before *y*. When returns `true`, then *x* precedes *y*. Default is {@link less}.
 *
 * @return Iterator to the first element not in heap order.
 */
function is_heap_until(first, last, comp) {
    if (comp === void 0) { comp = comparators_1.less; }
    if (global_1.distance(first, last) < 2)
        return last;
    // Determines the "level" of the biggest poplar seen so far
    var poplar_level = 1;
    var it = first;
    var next = it.next();
    while (true) {
        var poplar_size = 1;
        // The loop increment follows the binary carry sequence for some reason
        for (var i = (poplar_level & -poplar_level) >> 1; i !== 0; i >>= 1) {
            // Beginning and size of the poplar to track
            it = global_1.advance(it, -poplar_size);
            poplar_size = 2 * poplar_size + 1;
            // Check poplar property against child roots
            var root = global_1.advance(it, poplar_size - 1);
            if (root.equals(last))
                return next;
            else if (comp(root.value, root.prev().value))
                return next;
            else if (comp(root.value, global_1.advance(it, Math.floor(poplar_size / 2) - 1).value))
                return next;
            if (next.equals(last))
                return last;
            next = next.next();
        }
        if (next.equals(last))
            return last;
        it = next;
        next = next.next();
        ++poplar_level;
    }
}
exports.is_heap_until = is_heap_until;
/**
 * Sort elements of a heap.
 *
 * @param first Random access iteartor of the first position.
 * @param last Random access iterator of the last position.
 * @param comp A binary function predicates *x* element would be placed before *y*. When returns `true`, then *x* precedes *y*. Default is {@link less}.
 */
function sort_heap(first, last, comp) {
    if (comp === void 0) { comp = comparators_1.less; }
    while (!first.equals(last)) {
        pop_heap(first, last, comp);
        last = last.prev();
    }
}
exports.sort_heap = sort_heap;
/* ---------------------------------------------------------
    BACKGROUND
--------------------------------------------------------- */
/**
 * @hidden
 */
function _Hyper_floor(n) {
    for (var i = 1; i > 0; i <<= 1)
        n = n | (n >> 1);
    return n & ~(n >> 1);
}
/**
 * @hidden
 */
function _Sift(first, size, comp) {
    if (size < 2)
        return;
    var half_size = Math.floor(size / 2);
    // PRELIMINARIES
    var root = first.advance(size - 1);
    var child_root1 = root.prev();
    var child_root2 = first.advance(half_size - 1);
    // DETERMINE MAX-ROOT
    var max_root = root;
    if (comp(max_root.value, child_root1.value))
        max_root = child_root1;
    if (comp(max_root.value, child_root2.value))
        max_root = child_root2;
    // NEED ADDITIONAL SIFT?
    if (!max_root.equals(root)) {
        modifiers_1.iter_swap(root, max_root);
        _Sift(max_root.advance(-half_size + 1), half_size, comp);
    }
}
//# sourceMappingURL=heaps.js.map