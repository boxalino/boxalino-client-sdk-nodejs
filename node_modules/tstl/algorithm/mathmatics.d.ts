import { IForwardIterator } from "../iterator/IForwardIterator";
import { IBidirectionalIterator } from "../iterator/IBidirectionalIterator";
import { General } from "../iterator/IFake";
import { Pair } from "../utility/Pair";
/**
 * Get the minium value.
 *
 * @param items Items to search through.
 * @param comp A binary function predicates *x* element would be placed before *y*. When returns `true`, then *x* precedes *y*. Default is {@link less}.
 *
 * @return The minimum value.
 */
export declare function min<T>(items: T[], comp?: (x: T, y: T) => boolean): T;
/**
 * Get the maximum value.
 *
 * @param items Items to search through.
 * @param comp A binary function predicates *x* element would be placed before *y*. When returns `true`, then *x* precedes *y*. Default is {@link less}.
 *
 * @return The maximum value.
 */
export declare function max<T>(items: T[], comp?: (x: T, y: T) => boolean): T;
/**
 * Get the minimum & maximum values.
 *
 * @param items Items to search through.
 * @param comp A binary function predicates *x* element would be placed before *y*. When returns `true`, then *x* precedes *y*. Default is {@link less}.
 *
 * @return A {@link Pair} of minimum & maximum values.
 */
export declare function minmax<T>(items: T[], comp: (x: T, y: T) => boolean): Pair<T, T>;
/**
 * Get the minimum element in range.
 *
 * @param first Forward iterator of the first position.
 * @param last Forward iterator of the last position.
 * @param comp A binary function predicates *x* element would be placed before *y*. When returns `true`, then *x* precedes *y*. Default is {@link less}.
 *
 * @return Iterator to the minimum element.
 */
export declare function min_element<T, ForwardIterator extends Readonly<IForwardIterator<T, ForwardIterator>>>(first: ForwardIterator, last: ForwardIterator, comp?: (x: T, y: T) => boolean): ForwardIterator;
/**
 * Get the maximum element in range.
 *
 * @param first Forward iterator of the first position.
 * @param last Forward iterator of the last position.
 * @param comp A binary function predicates *x* element would be placed before *y*. When returns `true`, then *x* precedes *y*. Default is {@link less}.
 *
 * @return Iterator to the maximum element.
 */
export declare function max_element<T, ForwardIterator extends Readonly<IForwardIterator<T, ForwardIterator>>>(first: ForwardIterator, last: ForwardIterator, comp?: (x: T, y: T) => boolean): ForwardIterator;
/**
 * Get the minimum & maximum elements in range.
 *
 * @param first Forward iterator of the first position.
 * @param last Forward iterator of the last position.
 * @param comp A binary function predicates *x* element would be placed before *y*. When returns `true`, then *x* precedes *y*. Default is {@link less}.
 *
 * @return A {@link Pair} of iterators to the minimum & maximum elements.
 */
export declare function minmax_element<T, ForwardIterator extends Readonly<IForwardIterator<T, ForwardIterator>>>(first: ForwardIterator, last: ForwardIterator, comp?: (x: T, y: T) => boolean): Pair<ForwardIterator, ForwardIterator>;
/**
 * Get the clamp value.
 *
 * @param v The value to clamp.
 * @param lo Lower value than *hi*.
 * @param hi Higher value than *lo*.
 * @param comp A binary function predicates *x* element would be placed before *y*. When returns `true`, then *x* precedes *y*. Default is {@link less}.
 *
 * @return The clamp value.
 */
export declare function clamp<T>(v: T, lo: T, hi: T, comp?: (x: T, y: T) => boolean): T;
/**
 * Test whether two ranges are in permutation relationship.
 *
 * @param first1 Forward iteartor of the first position of the 1st range.
 * @param last1 Forward iterator of the last position of the 1st range.
 * @param first2 Forward iterator of the first position of the 2nd range.
 * @param pred A binary function predicates two arguments are equal. Default is {@link equal_to}.
 *
 * @return Whether permutation or not.
 */
export declare function is_permutation<T, ForwardIterator1 extends Readonly<IForwardIterator<T, ForwardIterator1>>, ForwardIterator2 extends Readonly<IForwardIterator<T, ForwardIterator2>>>(first1: ForwardIterator1, last1: ForwardIterator1, first2: ForwardIterator2, pred?: (x: T, y: T) => boolean): boolean;
/**
 * Transform to the previous permutation.
 *
 * @param first Bidirectional iterator of the first position.
 * @param last Bidirectional iterator of the last position.
 * @param comp A binary function predicates *x* element would be placed before *y*. When returns `true`, then *x* precedes *y*. Default is {@link less}.
 *
 * @return Whether the transformation was meaningful.
 */
export declare function prev_permutation<T, BidirectionalIterator extends General<IBidirectionalIterator<T, BidirectionalIterator>>>(first: BidirectionalIterator, last: BidirectionalIterator, comp?: (x: T, y: T) => boolean): boolean;
/**
 * Transform to the next permutation.
 *
 * @param first Bidirectional iterator of the first position.
 * @param last Bidirectional iterator of the last position.
 * @param comp A binary function predicates *x* element would be placed before *y*. When returns `true`, then *x* precedes *y*. Default is {@link less}.
 *
 * @return Whether the transformation was meaningful.
 */
export declare function next_permutation<T, BidirectionalIterator extends General<IBidirectionalIterator<T, BidirectionalIterator>>>(first: BidirectionalIterator, last: BidirectionalIterator, compare?: (x: T, y: T) => boolean): boolean;
//# sourceMappingURL=mathmatics.d.ts.map