import { Container } from "./Container";
import { _IAssociativeContainer } from "./_IAssociativeContainer";
import { SetIterator, SetReverseIterator } from "../iterator/SetIterator";
import { IForwardIterator } from "../../iterator/IForwardIterator";
import { Pair } from "../../utility/Pair";
/**
 * Base class for Set Containers.
 *
 * @author Jeongho Nam <http://samchon.org>
 */
export declare abstract class SetContainer<Key, Unique extends boolean, Source extends SetContainer<Key, Unique, Source>> extends Container<Key, Source, SetIterator<Key, Unique, Source>, SetReverseIterator<Key, Unique, Source>> implements _IAssociativeContainer<Key, SetIterator<Key, Unique, Source>> {
    /**
     * @hidden
     */
    private data_;
    /**
     * Default Constructor.
     */
    protected constructor();
    /**
     * @inheritDoc
     */
    assign<U extends Key, InputIterator extends Readonly<IForwardIterator<U, InputIterator>>>(first: InputIterator, last: InputIterator): void;
    /**
     * @inheritDoc
     */
    clear(): void;
    /**
     * @inheritDoc
     */
    abstract find(key: Key): SetIterator<Key, Unique, Source>;
    /**
     * @inheritDoc
     */
    begin(): SetIterator<Key, Unique, Source>;
    /**
     * @inheritDoc
     */
    end(): SetIterator<Key, Unique, Source>;
    /**
     * @inheritDoc
     */
    has(key: Key): boolean;
    /**
     * @inheritDoc
     */
    abstract count(key: Key): number;
    /**
     * @inheritDoc
     */
    size(): number;
    /**
     * @inheritDoc
     */
    push(...items: Key[]): number;
    insert(key: Key): SetContainer.InsertRet<Key, Unique, Source>;
    insert(hint: SetIterator<Key, Unique, Source>, key: Key): SetIterator<Key, Unique, Source>;
    insert<U extends Key, InputIterator extends Readonly<IForwardIterator<U, InputIterator>>>(first: InputIterator, last: InputIterator): void;
    /**
     * @hidden
     */
    protected abstract _Insert_by_key(key: Key): SetContainer.InsertRet<Key, Unique, Source>;
    /**
     * @hidden
     */
    protected abstract _Insert_by_hint(hint: SetIterator<Key, Unique, Source>, key: Key): SetIterator<Key, Unique, Source>;
    /**
     * @hidden
     */
    protected abstract _Insert_by_range<U extends Key, InputIterator extends Readonly<IForwardIterator<U, InputIterator>>>(begin: InputIterator, end: InputIterator): void;
    /**
     * @inheritDoc
     */
    erase(key: Key): number;
    /**
     * @inheritDoc
     */
    erase(it: SetIterator<Key, Unique, Source>): SetIterator<Key, Unique, Source>;
    /**
     * @inheritDoc
     */
    erase(begin: SetIterator<Key, Unique, Source>, end: SetIterator<Key, Unique, Source>): SetIterator<Key, Unique, Source>;
    /**
     * @hidden
     */
    protected abstract _Erase_by_val(key: Key): number;
    /**
     * @hidden
     */
    protected _Erase_by_range(first: SetIterator<Key, Unique, Source>, last?: SetIterator<Key, Unique, Source>): SetIterator<Key, Unique, Source>;
    /**
     * @hidden
     */
    swap(obj: Source): void;
    /**
     * @inheritDoc
     */
    abstract merge(source: Source): void;
    /**
     * @hidden
     */
    protected abstract _Handle_insert(first: SetIterator<Key, Unique, Source>, last: SetIterator<Key, Unique, Source>): void;
    /**
     * @hidden
     */
    protected abstract _Handle_erase(first: SetIterator<Key, Unique, Source>, last: SetIterator<Key, Unique, Source>): void;
}
export declare namespace SetContainer {
    type InsertRet<Key, Unique extends boolean, Source extends SetContainer<Key, Unique, Source>> = Unique extends true ? Pair<SetIterator<Key, Unique, Source>, boolean> : SetIterator<Key, Unique, Source>;
}
//# sourceMappingURL=SetContainer.d.ts.map