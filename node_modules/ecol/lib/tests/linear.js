"use strict";
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
var std = require("tstl");
var ecol = require("../index");
function process_tasks(task_list, container) {
    var e_1, _a;
    //----
    // PRELIMINARIES
    //----
    // LOG-VECTOR
    var ret = new std.Vector();
    // LISTENER FUNCTION
    var listener = function (event) {
        for (var it = event.first; !it.equals(event.last); it = it.next()) {
            var val = it.value;
            if (event.type === "erase")
                val *= -1;
            else if (event.type === "refresh")
                val = 1 / val;
            ret.push_back(val);
        }
    };
    // FILL ITEMS
    for (var i = 0; i < 100; ++i)
        container.push_back(i);
    // ADD-EVENT-LISTENERS
    container.addEventListener("insert", listener);
    container.addEventListener("erase", listener);
    container.addEventListener("refresh", listener);
    try {
        //----
        // PROCESS TASKS
        //----
        for (var task_list_1 = __values(task_list), task_list_1_1 = task_list_1.next(); !task_list_1_1.done; task_list_1_1 = task_list_1.next()) {
            var task = task_list_1_1.value;
            var it = std.advance(container.begin(), task[1]);
            if (task[0] === "insert") {
                var size = task[2];
                var p = Math.random();
                if (p < .5)
                    container.insert(it, size, 100);
                else {
                    var elements = [];
                    for (var i = 0; i < size; ++i)
                        elements.push(100);
                    container.insert(it, std.begin(elements), std.end(elements));
                }
            }
            else if (task[0] === "set")
                it.value = task[2];
            else {
                var last = std.advance(container.begin(), task[2]);
                if (task[0] === "erase")
                    container.erase(it, last);
                else
                    container.refresh(it, last);
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (task_list_1_1 && !task_list_1_1.done && (_a = task_list_1.return)) _a.call(task_list_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return ret;
}
function test_linear_containers() {
    var tasks = [
        ["erase", 17, 41],
        ["insert", 35, 9],
        ["insert", 9, 50],
        ["set", 15, 4],
        ["refresh", 27, 63],
        ["erase", 50, 110],
        ["insert", 0, 200],
        ["insert", 3, 4],
        ["set", 210, 1],
        ["erase", 40, 100],
        ["refresh", 0, 50] // 219
    ];
    var vec = new ecol.ArrayCollection();
    var deq = new ecol.DequeCollection();
    var list = new ecol.ListCollection();
    var r1 = process_tasks(tasks, vec);
    var r2 = process_tasks(tasks, deq);
    var r3 = process_tasks(tasks, list);
    if (std.equal(vec.begin(), vec.end(), deq.begin()) === false ||
        std.equal(vec.begin(), vec.end(), list.begin()) === false)
        throw new std.LogicError("Error on TSTL");
    else if (std.equal(r1.begin(), r1.end(), r2.begin()) === false ||
        std.equal(r1.begin(), r1.end(), r3.begin()) === false)
        throw new std.DomainError("Error on ECOL");
}
exports.test_linear_containers = test_linear_containers;
//# sourceMappingURL=linear.js.map