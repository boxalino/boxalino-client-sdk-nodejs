"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Entity_1 = require("../../protocol/entity/Entity");
var Invoke_1 = require("../../protocol/invoke/Invoke");
/**
 * History of an {@link Invoke} message.
 *
 * The {@link InvokeHistory} is a class archiving history log of an {@link Invoke} message with elapsed time. This
 * {@link InvokeHistory} class is used to report elapsed time of handling a requested process from **slave** to
 * **master** system.
 *
 * The **master** system utilizes derived {@link InvokeHistory} objects to compute performance indices.
 * - {@link ParallelSytem.getPerformance}
 * - {@link DistributedProcess.getResource}
 *
 * @author Jeongho Nam <http://samchon.org>
 */
var InvokeHistory = /** @class */ (function (_super) {
    __extends(InvokeHistory, _super);
    function InvokeHistory(invoke) {
        if (invoke === void 0) { invoke = null; }
        var _this = _super.call(this) || this;
        if (invoke == null) {
            // DEFAULT CONSTRUCTOR
            _this.uid = 0;
            _this.listener = "";
        }
        else {
            // CONSTRUCT FROM AN INVOKE MESSAGE
            _this.uid = invoke.get("_History_uid").getValue();
            _this.listener = invoke.getListener();
            _this.start_time_ = new Date();
        }
        return _this;
    }
    /**
     * @inheritdoc
     */
    InvokeHistory.prototype.construct = function (xml) {
        _super.prototype.construct.call(this, xml);
        this.start_time_ = new Date(parseInt(xml.getProperty("startTime")));
        this.end_time_ = new Date(parseInt(xml.getProperty("endTime")));
    };
    /**
     * Complete the history.
     *
     * Completes the history and determines the {@link getEndTime end time}.
     */
    InvokeHistory.prototype.complete = function () {
        this.end_time_ = new Date();
    };
    /* ---------------------------------------------------------
        ACCESSORS
    --------------------------------------------------------- */
    InvokeHistory.prototype.key = function () {
        return this.uid;
    };
    /**
     * Get unique ID.
     */
    InvokeHistory.prototype.getUID = function () {
        return this.uid;
    };
    /**
     * Get {@link Invoke.getListener listener} of the {@link Invoke} message.
     */
    InvokeHistory.prototype.getListener = function () {
        return this.listener;
    };
    /**
     * Get start time.
     */
    InvokeHistory.prototype.getStartTime = function () {
        return this.start_time_;
    };
    /**
     * Get end time.
     */
    InvokeHistory.prototype.getEndTime = function () {
        return this.end_time_;
    };
    /**
     * Compute elapsed time.
     *
     * @return nanoseconds.
     */
    InvokeHistory.prototype.computeElapsedTime = function () {
        return Math.max(this.end_time_.getTime() - this.start_time_.getTime(), 1);
    };
    /* ---------------------------------------------------------
        EXPORTERS
    --------------------------------------------------------- */
    /**
     * @inheritdoc
     */
    InvokeHistory.prototype.TAG = function () {
        return "history";
    };
    /**
     * @inheritdoc
     */
    InvokeHistory.prototype.toXML = function () {
        var xml = _super.prototype.toXML.call(this);
        xml.setProperty("startTime", this.start_time_.getTime() + "");
        xml.setProperty("endTime", this.end_time_.getTime() + "");
        return xml;
    };
    /**
     * Convert to an {@link Invoke} message.
     *
     * Creates and returns an {@link Invoke} message that is used to reporting to the **master**.
     */
    InvokeHistory.prototype.toInvoke = function () {
        return new Invoke_1.Invoke("_Report_history", this.toXML());
    };
    return InvokeHistory;
}(Entity_1.Entity));
exports.InvokeHistory = InvokeHistory;
//# sourceMappingURL=InvokeHistory.js.map