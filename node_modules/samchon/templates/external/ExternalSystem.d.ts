import { EntityDequeCollection } from "../../protocol/entity/EntityCollection";
import { ExternalSystemRole } from "./ExternalSystemRole";
import { ExternalSystemArray } from "./ExternalSystemArray";
import { IProtocol } from "../../protocol/invoke/IProtocol";
import { ICommunicator } from "../../protocol/communicator/ICommunicator";
import { IClientDriver } from "../../protocol/communicator/IClientDriver";
import { Invoke } from "../../protocol/invoke/Invoke";
/**
 * An external system driver.
 *
 * The {@link ExternalSystem} class represents an external system, connected and interact with this system.
 * {@link ExternalSystem} takes full charge of network communication with the remote, external system have connected.
 * Replied {@link Invoke} messages from the external system is shifted to and processed in, children elements of this
 * class, {@link ExternalSystemRole} objects.
 *
 * <a href="http://samchon.github.io/framework/images/design/ts_class_diagram/templates_external_system.png"
 *		  target="_blank">
 *	<img src="http://samchon.github.io/framework/images/design/ts_class_diagram/templates_external_system.png"
 *		 style="max-width: 100%" />
 * </a>
 *
 * #### Bridge & Proxy Pattern
 * The {@link ExternalSystem} class can be a *bridge* for *logical proxy*. In framework within user,
 * which {@link ExternalSystem external system} is connected with {@link ExternalSystemArray this system}, it's not
 * important. Only interested in user's perspective is *which can be done*.
 *
 * By using the *logical proxy*, user dont't need to know which {@link ExternalSystemRole role} is belonged
 * to which {@link ExternalSystem system}. Just access to a role directly from {@link ExternalSystemArray.getRole}.
 * Sends and receives {@link Invoke} message via the {@link ExternalSystemRole role}.
 *
 * <ul>
 *	<li>
 *		{@link ExternalSystemRole} can be accessed from {@link ExternalSystemArray} directly, without inteferring
 *		from {@link ExternalSystem}, with {@link ExternalSystemArray.getRole}.
 *	</li>
 *	<li>
 *		When you want to send an {@link Invoke} message to the belonged {@link ExternalSystem system}, just call
 *		{@link ExternalSystemRole.sendData ExternalSystemRole.sendData()}. Then, the message will be sent to the
 *		external system.
 *	</li>
 *	<li> Those strategy is called *Bridge Pattern* and *Proxy Pattern*. </li>
 * </ul>
 *
 * @handbook [Templates - External System](https://github.com/samchon/framework/wiki/TypeScript-Templates-External_System)
 * @author Jeongho Nam <http://samchon.org>
 */
export declare abstract class ExternalSystem extends EntityDequeCollection<ExternalSystemRole> implements IProtocol {
    /**
     * The name represents external system have connected.
     */
    protected name: string;
    /**
     * @hidden
     */
    private system_array_;
    /**
     * @hidden
     */
    private communicator_;
    /**
     * Construct from parent {@link ExternalSystemArray}.
     *
     * @param systemArray The parent {@link ExternalSystemArray} object.
     */
    constructor(systemArray: ExternalSystemArray<ExternalSystem>);
    /**
     * Constrct from parent {@link ExternalSystemArray} and communicator.
     *
     * @param systemArray The parent {@link ExternalSystemArray} object.
     * @param communicator Communicator with the remote, external system.
     */
    constructor(systemArray: ExternalSystemArray<ExternalSystem>, communicator: IClientDriver);
    /**
     * Default Destructor.
     *
     * This {@link destructor destructor()} method is called when the {@link ExternalSystem} object is destructed and
     * the {@link ExternalSystem} object is destructed when connection with the remote system is closed or this
     * {@link ExternalSystem} object is {@link ExternalSystemArray.erase erased} from its parent
     * {@link ExternalSystemArray} object.
     *
     * Note that, don't call this {@link destructor destructor()} method by yourself. It must be called automatically
     * by those *destruction* cases. Also, if your derived {@link ExternalSystem} class has something to do on the
     * *destruction*, then overrides this {@link destructor destructor()} method and defines the something to do.
     * Overriding this {@link destructor destructor()}, don't forget to calling ```super.destructor();``` on tail.
     *
     * ```typescript
     * class SomeSystem extends templates.external.ExternalSystem
     * {
     *     protected destructor(): void
     *     {
     *         // DO SOMETHING
     *         this.do_something();
     *
     *         // CALL SUPER.DESTRUCTOR() ON TAIL. DON'T FORGET THIS
     *         super.destructor();
     *     }
     * }
     * ```
     */
    protected destructor(): void;
    /**
     * @hidden
     */
    private _Handle_close;
    /**
     * Get parent {@link ExternalSystemArray} object.
     */
    getSystemArray(): ExternalSystemArray<ExternalSystem>;
    /**
     * Get parent {@link ExternalSystemArray} object.
     */
    getSystemArray<SystemArray extends ExternalSystemArray<ExternalSystem>>(): SystemArray;
    /**
     * Identifier of {@link ExternalSystem} is its {@link name}.
     *
     * @return name.
     */
    key(): string;
    /**
     * Get {@link name}.
     */
    getName(): string;
    /**
     * @hidden
     */
    /**
    * @hidden
    */
    protected communicator: ICommunicator;
    /**
     * Close connection.
     */
    close(): void;
    /**
     * Send {@link Invoke} message to external system.
     *
     * @param invoke An {@link Invoke} message to send.
     */
    sendData(invoke: Invoke): void;
    /**
     * Handle an {@Invoke} message has received.
     *
     * @param invoke An {@link Invoke} message have received.
     */
    replyData(invoke: Invoke): void;
    /**
     * Tag name of the {@link ExternalSystem} in {@link XML}.
     *
     * @return *system*.
     */
    TAG(): string;
    /**
     * Tag name of {@link ExternalSystemRole children elements} belonged to the {@link ExternalSystem} in {@link XML}.
     *
     * @return *role*.
     */
    CHILD_TAG(): string;
}
