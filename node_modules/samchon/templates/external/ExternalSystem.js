"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var std = require("tstl");
var EntityCollection_1 = require("../../protocol/entity/EntityCollection");
/**
 * An external system driver.
 *
 * The {@link ExternalSystem} class represents an external system, connected and interact with this system.
 * {@link ExternalSystem} takes full charge of network communication with the remote, external system have connected.
 * Replied {@link Invoke} messages from the external system is shifted to and processed in, children elements of this
 * class, {@link ExternalSystemRole} objects.
 *
 * <a href="http://samchon.github.io/framework/images/design/ts_class_diagram/templates_external_system.png"
 *		  target="_blank">
 *	<img src="http://samchon.github.io/framework/images/design/ts_class_diagram/templates_external_system.png"
 *		 style="max-width: 100%" />
 * </a>
 *
 * #### Bridge & Proxy Pattern
 * The {@link ExternalSystem} class can be a *bridge* for *logical proxy*. In framework within user,
 * which {@link ExternalSystem external system} is connected with {@link ExternalSystemArray this system}, it's not
 * important. Only interested in user's perspective is *which can be done*.
 *
 * By using the *logical proxy*, user dont't need to know which {@link ExternalSystemRole role} is belonged
 * to which {@link ExternalSystem system}. Just access to a role directly from {@link ExternalSystemArray.getRole}.
 * Sends and receives {@link Invoke} message via the {@link ExternalSystemRole role}.
 *
 * <ul>
 *	<li>
 *		{@link ExternalSystemRole} can be accessed from {@link ExternalSystemArray} directly, without inteferring
 *		from {@link ExternalSystem}, with {@link ExternalSystemArray.getRole}.
 *	</li>
 *	<li>
 *		When you want to send an {@link Invoke} message to the belonged {@link ExternalSystem system}, just call
 *		{@link ExternalSystemRole.sendData ExternalSystemRole.sendData()}. Then, the message will be sent to the
 *		external system.
 *	</li>
 *	<li> Those strategy is called *Bridge Pattern* and *Proxy Pattern*. </li>
 * </ul>
 *
 * @handbook [Templates - External System](https://github.com/samchon/framework/wiki/TypeScript-Templates-External_System)
 * @author Jeongho Nam <http://samchon.org>
 */
var ExternalSystem = /** @class */ (function (_super) {
    __extends(ExternalSystem, _super);
    function ExternalSystem(systemArray, communicator) {
        if (communicator === void 0) { communicator = null; }
        var _this = _super.call(this) || this;
        _this.system_array_ = systemArray;
        _this.communicator = communicator;
        if (communicator != null)
            communicator.listen(_this);
        _this.name = "";
        return _this;
    }
    /**
     * Default Destructor.
     *
     * This {@link destructor destructor()} method is called when the {@link ExternalSystem} object is destructed and
     * the {@link ExternalSystem} object is destructed when connection with the remote system is closed or this
     * {@link ExternalSystem} object is {@link ExternalSystemArray.erase erased} from its parent
     * {@link ExternalSystemArray} object.
     *
     * Note that, don't call this {@link destructor destructor()} method by yourself. It must be called automatically
     * by those *destruction* cases. Also, if your derived {@link ExternalSystem} class has something to do on the
     * *destruction*, then overrides this {@link destructor destructor()} method and defines the something to do.
     * Overriding this {@link destructor destructor()}, don't forget to calling ```super.destructor();``` on tail.
     *
     * ```typescript
     * class SomeSystem extends templates.external.ExternalSystem
     * {
     *     protected destructor(): void
     *     {
     *         // DO SOMETHING
     *         this.do_something();
     *
     *         // CALL SUPER.DESTRUCTOR() ON TAIL. DON'T FORGET THIS
     *         super.destructor();
     *     }
     * }
     * ```
     */
    ExternalSystem.prototype.destructor = function () {
        if (this.communicator != null && this.communicator.isConnected() == true) {
            this.communicator.onClose = null;
            this.communicator.close();
        }
    };
    /**
     * @hidden
     */
    ExternalSystem.prototype._Handle_close = function () {
        if (this.system_array_ == null)
            return;
        else
            this.system_array_.erase(std.remove(this.system_array_.begin(), this.system_array_.end(), this), this.system_array_.end());
    };
    ExternalSystem.prototype.getSystemArray = function () {
        return this.system_array_;
    };
    /**
     * Identifier of {@link ExternalSystem} is its {@link name}.
     *
     * @return name.
     */
    ExternalSystem.prototype.key = function () {
        return this.name;
    };
    /**
     * Get {@link name}.
     */
    ExternalSystem.prototype.getName = function () {
        return this.name;
    };
    Object.defineProperty(ExternalSystem.prototype, "communicator", {
        /**
         * @hidden
         */
        get: function () {
            return this.communicator_;
        },
        /**
         * @hidden
         */
        set: function (val) {
            this.communicator_ = val;
            if (this.communicator_ != null)
                this.communicator.onClose = this._Handle_close.bind(this);
        },
        enumerable: true,
        configurable: true
    });
    /* ---------------------------------------------------------
        NETWORK & MESSAGE CHAIN
    --------------------------------------------------------- */
    /**
     * Close connection.
     */
    ExternalSystem.prototype.close = function () {
        this.communicator.close();
    };
    /**
     * Send {@link Invoke} message to external system.
     *
     * @param invoke An {@link Invoke} message to send.
     */
    ExternalSystem.prototype.sendData = function (invoke) {
        this.communicator.sendData(invoke);
    };
    /**
     * Handle an {@Invoke} message has received.
     *
     * @param invoke An {@link Invoke} message have received.
     */
    ExternalSystem.prototype.replyData = function (invoke) {
        // SHIFT TO SYSTEM_ARRAY
        this.system_array_.replyData(invoke);
        // SHIFT TO ROLES
        for (var i = 0; i < this.size(); i++)
            this.at(i).replyData(invoke);
    };
    /* ---------------------------------------------------------
        EXPORTERS
    --------------------------------------------------------- */
    /**
     * Tag name of the {@link ExternalSystem} in {@link XML}.
     *
     * @return *system*.
     */
    ExternalSystem.prototype.TAG = function () {
        return "system";
    };
    /**
     * Tag name of {@link ExternalSystemRole children elements} belonged to the {@link ExternalSystem} in {@link XML}.
     *
     * @return *role*.
     */
    ExternalSystem.prototype.CHILD_TAG = function () {
        return "role";
    };
    return ExternalSystem;
}(EntityCollection_1.EntityDequeCollection));
exports.ExternalSystem = ExternalSystem;
//# sourceMappingURL=ExternalSystem.js.map