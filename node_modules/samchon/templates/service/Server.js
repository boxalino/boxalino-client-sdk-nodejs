"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var std = require("tstl");
var WebServer_1 = require("../../protocol/server/WebServer");
/**
 * A cloud server.
 *
 * The {@link Server} is an abstract server class, who can build a real-time cloud server, that is following the
 * web-socket  Extends this {@link Server} and related classes and overrides abstract methods under below.
 * After the overridings, open this {@link Server cloud server} using the {@link open open()} method.
 *
 * - Objects in composite relationship and their factory methods
 *   - {@link User}: {@link Server.createUser Server.createUser()}
 *   - {@link Client}: {@link User.createClient User.createClient()}
 *   - {@link Service}: {@link Client.createService Client.createService()}
 * - {@link Invoke} message chains; {@link IProtocol.replyData replyData}
 *   - {@link Server.replyData}
 *   - {@link User.replyData}
 *   - {@link Client.replyData}
 *   - {@link Service.replyData}
 *
 * <a href="http://samchon.github.io/framework/images/design/ts_class_diagram/templates_cloud_service.png" target="_blank">
 *	<img src="http://samchon.github.io/framework/images/design/ts_class_diagram/templates_cloud_service.png"
    *		 style="max-width: 100%" />
    * </a>
    *
    * @handbook [Templates - Cloud Service](https://github.com/samchon/framework/wiki/TypeScript-Templates-Cloud_Service)
    * @author Jeongho Nam <http://samchon.org>
    */
var Server = /** @class */ (function (_super) {
    __extends(Server, _super);
    /* ------------------------------------------------------------------
        CONSTRUCTORS
    ------------------------------------------------------------------ */
    /**
     * Default Constructor.
     */
    function Server() {
        var _this = _super.call(this) || this;
        // INITIALIZE USER MAPS
        _this.session_map_ = new std.HashMap();
        _this.account_map_ = new std.HashMap();
        return _this;
    }
    /* ------------------------------------------------------------------
        ACCESSORS
    ------------------------------------------------------------------ */
    /**
     * Test wheter an {@link User} exists with the *accountID*.
     *
     * @param accountID Account id of {@link User} to find.
     * @return Exists or not.
     */
    Server.prototype.has = function (accountID) {
        return this.account_map_.has(accountID);
    };
    /**
     * Get an {@link User} object by its *accountID*.
     *
     * @param accountID Account id of {@link User} to get.
     * @return An {@link User} object.
     */
    Server.prototype.get = function (accountID) {
        return this.account_map_.get(accountID);
    };
    /* ------------------------------------------------------------------
        MESSAGE CHAIN
    ------------------------------------------------------------------ */
    /**
     * Send an {@link Invoke} message.
     *
     * Sends an {@link Invoke} message to all remote clients through the belonged {@link User} and {@link Client}
     * objects. Sending the {@link Invoke} message to all remote clients, it's came true by passing through
     * {@link User.sendData User.sendData()}. And the {@link User.sendData} also pass through the
     * {@link Client.sendData Client.sendData()}.
     *
     * ```typescript
     * class service.Server
     * {
     *     public sendData(invoke: Invoke): void
     *     {
     *         for (user: User in this)
     *             for (client: Client in user)
     *                 client.sendData(invoke);
     *     }
     * }
     * ```
     *
     * @param invoke {@link Invoke} message to send to all remote clients.
     */
    Server.prototype.sendData = function (invoke) {
        for (var it = this.session_map_.begin(); !it.equals(this.session_map_.end()); it = it.next())
            it.second.sendData(invoke);
    };
    /* ------------------------------------------------------------------
        CLIENT I/O
    ------------------------------------------------------------------ */
    /**
     * Add a newly connected remote client.
     *
     * When a {@link WebClientDriver remote client} connects to this cloud server, then {@link Server} queries the
     * {WebClientDriver.getSessionID session id} of the {@link WebClientDriver remote client}. If the
     * {WebClientDriver.getSessionID session id} is new one, then creates a new {@link User} object.
     *
     * At next, creates a {@link Client} object who represents the newly connected remote client and insert the
     * {@link Client} object to the matched {@link User} object which is new or ordinary one following the
     * {WebClientDriver.getSessionID session id}. At last, a {@link Service} object can be created with referencing
     * the {@link WebClientDriver.getPath path}.
     *
     * List of objects can be created by this method.
     * - {@link User} by {@link createUser createUser()}.
     * - {@link Client} by {@link User.createClient User.createClient()}.
     * - {@link Service} by {@link Client.createService Client.createService()}.
     *
     * @param driver A web communicator for remote client.
     */
    Server.prototype.addClient = function (driver) {
        //--------
        // CREATE CHILDREN OBJECTS
        //--------
        // USER
        var user;
        if (this.session_map_.has(driver.getSessionID()) == true)
            user = this.session_map_.get(driver.getSessionID());
        else {
            user = this.createUser();
            user["session_id_"] = (driver.getSessionID());
            this.session_map_.insert(std.make_pair(driver.getSessionID(), user));
        }
        //--------
        // CLIENT
        //--------
        // SERVICE IS CREEATED IN CLIENT'S CONSTRUCTOR
        var client = user["createClient"](driver);
        user.insert(std.make_pair(client.getNo(), client));
        // CLOSE HANDLER
        driver.onClose = function () {
            // WHEN DISCONNECTED, THEN ERASE THE CLIENT.
            // OF COURSE, IT CAN CAUSE DELETION OF THE RELATED USER.
            user.erase(client.getNo());
            // ALSO, DESTRUCTORS OF THE SERVICE ARE CALLED.
            if (client.getService() != null)
                client.getService()["destructor"](); // SERVICE
            client["destructor"](); // AND CLIENT
        };
    };
    /**
     * @hidden
     */
    Server.prototype._Erase_user = function (user) {
        // USER DOESN'T BE ERASED AT THAT TIME
        // IT WAITS UNTIL 30 SECONDS TO KEEP SESSION
        setTimeout(function () {
            var server = this;
            if (user.empty() == false)
                return; // USER IS NOT EMPTY, THEN RETURNS
            // ERASE USER FROM
            server.session_map_.erase(user["session_id_"]); // SESSION-ID MAP
            if (user.getAccountID() != "") // AND ACCOUNT-ID MAP
                server.account_map_.erase(user.getAccountID());
            // CALL DESTRUCTOR
            user["destructor"]();
        }.bind(this), 30000 // KEEP USER 30 SECONDS
        );
    };
    return Server;
}(WebServer_1.WebServer));
exports.Server = Server;
//# sourceMappingURL=Server.js.map