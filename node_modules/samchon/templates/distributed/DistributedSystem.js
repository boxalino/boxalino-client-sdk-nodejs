"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ParallelSystem_1 = require("../parallel/ParallelSystem");
var DSInvokeHistory_1 = require("./DSInvokeHistory");
/**
 * A driver for a distributed slave system.
 *
 * The {@link DistributedSystem} is an abstract class represents a **slave** system in *Distributed Processing System*,
 * connected with this **master** system. This {@link DistributedSystem} takes full charge of network communication
 * with the remote, distributed **slave** system has connected.
 *
 * This {@link DistributedSystem} has a {@link getPerformance performance index} that indicates how much the **slave**
 * system is fast. The {@link getPerformance performance index} is referenced and revaluated whenever those methods
 * are called:
 *
 * - Requesting a *parallel process*
 *   - {@link DistributedSystemArray.sendSegmentData}
 *   - {@link DistributedSystemArray.sendPieceData}
 * - Requesting a *distributed process*: {@link DistributedProcess.sendData}
 *
 * Note that, this {@link DistributedSystem} class derived from the {@link ExternalSystem} class. Thus, this
 * {@link DistributedSystem} can also have children {@link ExternalSystemRole} objects exclusively. However, the
 * children {@link ExternalSystemRole roles} objects are different with the {@link DistributedProcess}. The
 * domestic {@link ExternalSystemRole roles} are belonged to only a specific {@link DistributedSystem} object.
 * Otherwise, the {@link DistributedProcess} objects are belonged to a {@link DistributedSystemArray} object.
 * Furthermore, the relationship between this {@link DistributedSystem} and {@link DistributedProcess} classes are
 * **M: N Associative**.
 *
 * Articles     | {@link DistributedProcess}     | {@link ExternalSystemRole}
 * -------------|--------------------------------|----------------------------
 * Belonged to  | {@link DistributedSystemArray} | {@link DistributedSystem}
 * Relationship | M: N Associative               | 1: N Composite
 * Ownership    | References                     | Exclusive possession
 *
 * <a href="http://samchon.github.io/framework/images/design/ts_class_diagram/templates_distributed_system.png"
 *		  target="_blank">
    *	<img src="http://samchon.github.io/framework/images/design/ts_class_diagram/templates_distributed_system.png"
    *		 style="max-width: 100%" />
    * </a>
    *
    * @handbook [Templates - Distributed System](https://github.com/samchon/framework/wiki/TypeScript-Templates-Distributed_System)
    * @author Jeongho Nam <http://samchon.org>
    */
var DistributedSystem = /** @class */ (function (_super) {
    __extends(DistributedSystem, _super);
    function DistributedSystem(systemArray, communicator) {
        if (communicator === void 0) { communicator = null; }
        return _super.call(this, systemArray, communicator) || this;
    }
    // using super::destructor
    /**
     * Factory method creating a {@link ExternalSystemRole child} object.
     *
     * In {@link distributed} module, the process class {@link DistributedProcess} is not belonged to a specific
     * {@link DistributedSystem} object. It only belongs to a {@link DistributedSystemArray} object and has a
     * **M: N Associative Relationship** between this {@link DistributedSystem} class.
     *
     * By that reason, it's the normal case that the {@link DistributedSystem} object does not have any children
     * {@link ExternalSystemRole} object. Thus, default {@link createChild} returns ```null```.
     *
     * However, if you want a {@link DistributedSystem} to have its own domestic {@link ExternalSystemRole} objects
     * without reference to the {@link DistributedProcess} objects, it is possible. Creates and returns the
     * domestic {@link ExternalSystemRole} object.
     *
     * @param xml {@link XML} represents the {@link ExternalSystemRole child} object.
     * @return A newly created {@link ExternalSystemRole} object or ```null```.
     */
    DistributedSystem.prototype.createChild = function (xml) {
        return null;
    };
    DistributedSystem.prototype.getSystemArray = function () {
        return this["system_array_"];
    };
    /**
     * @hidden
     */
    DistributedSystem.prototype._Compute_average_elapsed_time = function () {
        var sum = 0;
        var denominator = 0;
        for (var it = this["history_list_"].begin(); !it.equals(this["history_list_"].end()); it = it.next()) {
            var history_1 = it.second;
            if (history_1 instanceof DSInvokeHistory_1.DSInvokeHistory == false)
                continue;
            var elapsed_time = history_1.computeElapsedTime() / history_1.getWeight();
            sum += elapsed_time / history_1.getProcess().getResource();
            denominator++;
        }
        if (denominator == 0)
            return -1;
        else
            return sum / denominator;
    };
    /* ---------------------------------------------------------
        MESSAGE CHAIN
    --------------------------------------------------------- */
    /**
     * @inheritdoc
     */
    DistributedSystem.prototype.replyData = function (invoke) {
        // SHIFT TO ROLES
        var role_map = this.getSystemArray().getProcessMap();
        for (var it = role_map.begin(); !it.equals(role_map.end()); it = it.next())
            it.second.replyData(invoke);
        // SHIFT TO PARENT AND CHIILDREN, EXCLUSIVE ROLES
        _super.prototype.replyData.call(this, invoke);
    };
    /**
     * @hidden
     */
    DistributedSystem.prototype._Report_history = function (xml) {
        // ParallelSystem's history -> PRInvokeHistory
        if (xml.hasProperty("_Piece_first") == true)
            return _super.prototype._Report_history.call(this, xml);
        //--------
        // DistributedProcess's history -> DSInvokeHistory
        //--------
        // CONSTRUCT HISTORY
        var history = new DSInvokeHistory_1.DSInvokeHistory(this);
        history.construct(xml);
        // IF THE HISTORY HAS NOT EXISTED IN PROGRESS, THEN TERMINATE REPORTING
        var progress_it = this["progress_list_"].find(history.getUID());
        if (progress_it.equals(this["progress_list_"].end()) == true)
            return;
        history["process_"] = progress_it.second.second.getProcess();
        history["weight_"] = progress_it.second.second.getWeight();
        // ERASE FROM ORDINARY PROGRESS AND MIGRATE TO THE HISTORY
        this["progress_list_"].erase(progress_it);
        this["history_list_"].emplace(history.getUID(), history);
        // REPORT TO THE ROLE
        if (history.getProcess() != null)
            history.getProcess()["_Complete_history"](history);
        // COMPLETE THE HISTORY IN THE BELONGED SYSTEM_ARRAY
        this.getSystemArray()["_Complete_history"](history);
    };
    /**
     * @hidden
     */
    DistributedSystem.prototype._Send_back_history = function (invoke, history) {
        if (history instanceof DSInvokeHistory_1.DSInvokeHistory) {
            // RE-SEND INVOKE MESSAGE TO ANOTHER SLAVE VIA ROLE
            history.getProcess().sendData(invoke, history.getWeight());
        }
        // ERASE THE HISTORY
        _super.prototype._Send_back_history.call(this, invoke, history);
    };
    return DistributedSystem;
}(ParallelSystem_1.ParallelSystem));
exports.DistributedSystem = DistributedSystem;
//# sourceMappingURL=DistributedSystem.js.map