import * as std from "tstl";
import { ParallelSystemArray } from "../parallel/ParallelSystemArray";
import { DistributedSystem } from "./DistributedSystem";
import { DistributedProcess } from "./DistributedProcess";
import { InvokeHistory } from "../slave/InvokeHistory";
import { XML } from "sxml";
/**
 * Master of Distributed Processing System.
 *
 * The {@link DistributedSystemArray} is an abstract class containing and managing remote distributed **slave** system
 * drivers, {@link DistributedSystem} objects. Within framework of network, {@link DistributedSystemArray} represents
 * your system, a **Master** of *Distributed Processing System* that requesting *distributed process* to **slave**
 * systems and the children {@link DistributedSystem} objects represent the remote **slave** systems, who is being
 * requested the *distributed processes*.
 *
 * You can specify this {@link DistributedSystemArray} class to be *a server accepting distributed clients* or
 * *a client connecting to distributed servers*. Even both of them is possible. Extends one of them below and overrides
 * abstract factory method(s) creating the child {@link DistributedSystem} object.
 *
 * - {@link DistributedClientArray}: A server accepting {@link DistributedSystem distributed clients}.
 * - {@link DistributedServerArray}: A client connecting to {@link DistributedServer distributed servers}.
 * - {@link DistributedServerClientArray}: Both of them. Accepts {@link DistributedSystem distributed clients} and
 *   connects to {@link DistributedServer distributed servers} at the same time.
 *
 * The {@link DistributedSystemArray} contains {@link DistributedProcess} objects directly. You can request a
 * **distributed process** through the {@link DistributedProcess} object. You can access the
 * {@link DistributedProcess} object(s) with those methods:
 *
 * - {@link hasProcess}
 * - {@link getProcess}
 * - {@link insertProcess}
 * - {@link eraseProcess}
 * - {@link getProcessMap}
 *
 * When you need the **distributed process**, call the {@link DistributedProcess.sendData} method. Then the
 * {@link DistributedProcess} will find the most idle {@link DistributedSystem} object who represents a distributed
 * **slave **system. The {@link Invoke} message will be sent to the most idle {@link DistributedSystem} object. When
 * the **distributed process** has completed, then {@link DistributedSystem.getPerformance performance index} and
 * {@link DistributedProcess.getResource resource index} of related objects will be revaluated.
 *
 * <a href="http://samchon.github.io/framework/images/design/ts_class_diagram/templates_distributed_system.png"
 *		  target="_blank">
    *	<img src="http://samchon.github.io/framework/images/design/ts_class_diagram/templates_distributed_system.png"
    *		 style="max-width: 100%" />
    * </a>
    *
    * #### Parallel Process
    * This {@link DistributedSystemArray} class is derived from the {@link ParallelSystemArray} class, so you can request
    * a **parallel process**, too.
    *
    * When you need the **parallel process**, then call one of them: {@link sendSegmentData} or {@link sendPieceData}.
    * When the **parallel process** has completed, {@link ParallelSystemArray} estimates each {@link ParallelSystem}'s
    * {@link ParallelSystem.getPerformance performance index} basis on their execution time. Those performance indices will
    * be reflected to the next **parallel process**, how much pieces to allocate to each {@link ParallelSystem}.
    *
    * #### Proxy Pattern
    * This class {@link DistributedSystemArray} is derived from the {@link ExternalSystemArray} class. Thus, you can take
    * advantage of the *Proxy Pattern* in the {@link DistributedSystemArray} class. If a process to request is not the
    * *parallel process* (to be distrubted to all slaves), but the **exclusive process** handled in a system, then it
    * may better to utilizing the *Proxy Pattern*:
    *
    * The {@link ExternalSystemArray} class can use *Proxy Pattern*. In framework within user, which
    * {@link ExternalSystem external system} is connected with {@link ExternalSystemArray this system}, it's not
    * important. Only interested in user's perspective is *which can be done*.
    *
    * By using the *logical proxy*, user dont't need to know which {@link ExternalSystemRole role} is belonged
    * to which {@link ExternalSystem system}. Just access to a role directly from {@link ExternalSystemArray.getRole}.
    * Sends and receives {@link Invoke} message via the {@link ExternalSystemRole role}.
    *
    * <ul>
    *	<li>
    *		{@link ExternalSystemRole} can be accessed from {@link ExternalSystemArray} directly, without inteferring
    *		from {@link ExternalSystem}, with {@link ExternalSystemArray.getRole}.
    *	</li>
    *	<li>
    *		When you want to send an {@link Invoke} message to the belonged {@link ExternalSystem system}, just call
    *		{@link ExternalSystemRole.sendData ExternalSystemRole.sendData()}. Then, the message will be sent to the
    *		external system.
    *	</li>
    *	<li> Those strategy is called *Proxy Pattern*. </li>
    * </ul>
    *
    * @handbook [Templates - Distributed System](https://github.com/samchon/framework/wiki/TypeScript-Templates-Distributed_System)
    * @author Jeongho Nam <http://samchon.org>
    */
export declare abstract class DistributedSystemArray<System extends DistributedSystem> extends ParallelSystemArray<System> {
    /**
     * @hidden
     */
    private process_map_;
    /**
     * Default Constructor.
     */
    constructor();
    /**
     * @inheritdoc
     */
    construct(xml: XML): void;
    /**
     * Factory method creating a child {@link DistributedProcess process} object.
     *
     * @param xml {@link XML} represents the {@link DistributedProcess child} object.
     * @return A new {@link DistributedProcess} object.
     */
    protected abstract createProcess(xml: XML): DistributedProcess;
    /**
     * Get process map.
     *
     * Gets an {@link HashMap} containing {@link DistributedProcess} objects with their *key*.
     *
     * @return An {@link HasmMap> containing pairs of string and {@link DistributedProcess} object.
     */
    getProcessMap(): std.HashMap<string, DistributedProcess>;
    /**
     * Test whether the process exists.
     *
     * @param name Name, identifier of target {@link DistributedProcess process}.
     *
     * @return Whether the process has or not.
     */
    hasProcess(name: string): boolean;
    /**
     * Get a process.
     *
     * @param name Name, identifier of target {@link DistributedProcess process}.
     *
     * @return The specified process.
     */
    getProcess(name: string): DistributedProcess;
    /**
     * Insert a process.
     *
     * @param process A process to be inserted.
     * @return Success flag.
     */
    insertProcess(process: DistributedProcess): boolean;
    /**
     * Erase a process.
     *
     * @param name Name, identifier of target {@link DistributedProcess process}.
     */
    eraseProcess(name: string): boolean;
    /**
     * @hidden
     */
    protected _Complete_history(history: InvokeHistory): boolean;
    /**
     * @hidden
     */
    private estimate_process_resource;
    /**
     * @hidden
     */
    private estimate_system_performance;
    /**
     * @hidden
     */
    protected _Normalize_performance(): void;
    /**
     * @inheritdoc
     */
    toXML(): XML;
}
