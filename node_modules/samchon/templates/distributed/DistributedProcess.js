"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var std = require("tstl");
var Entity_1 = require("../../protocol/entity/Entity");
var DSInvokeHistory_1 = require("./DSInvokeHistory");
var InvokeParameter_1 = require("../../protocol/invoke/InvokeParameter");
/**
 * A process of Distributed Processing System.
 *
 * The {@link DistributedProcess} is an abstract class who represents a **process**, *SOMETHING TO DISTRIBUTE* in a Distributed
 * Processing System. Overrides the {@link DistributedProcess} and defines the *SOMETHING TO DISTRIBUTE*.
 *
 * Relationship between {@link DistributedSystem} and {@link DistributedProcess} objects are **M: N Associative**.
 * Unlike {@link ExternalSystemRole}, the {@link DistributedProcess} objects are not belonged to a specific
 * {@link DistributedSystem} object. The {@link DistributedProcess} objects are belonged to the
 * {@link DistributedSystemArrayMediator} directly.
 *
 * When you need the **distributed process**, then call {@link sendData sendData()}. The {@link sendData} will find
 * the most idle {@link DistributedSystem slave system} considering not only number of processes on progress, but also
 * {@link DistributedSystem.getPerformance performance index} of each {@link DistributedSystem} object and
 * {@link getResource resource index} of this {@link DistributedProcess} object. The {@link Invoke} message
 * requesting the **distributed process** will be sent to the most idle {@link DistributedSystem slave system}.
 *
 * Those {@link DistributedSystem.getPerformance performance index} and {@link getResource resource index} are
 * revaluated whenever the **distributed process** has completed basis on the execution time.
 *
 * <a href="http://samchon.github.io/framework/images/design/ts_class_diagram/templates_distributed_system.png"
 *		  target="_blank">
    *	<img src="http://samchon.github.io/framework/images/design/ts_class_diagram/templates_distributed_system.png"
    *		 style="max-width: 100%" />
    * </a>
    *
    * @handbook [Templates - Distributed System](https://github.com/samchon/framework/wiki/TypeScript-Templates-Distributed_System)
    * @author Jeongho Nam <http://samchon.org>
    */
var DistributedProcess = /** @class */ (function (_super) {
    __extends(DistributedProcess, _super);
    /* ---------------------------------------------------------
        CONSTRUCTORS
    --------------------------------------------------------- */
    /**
     * Constrct from parent {@link DistributedSystemArray} object.
     *
     * @param systemArray The parent {@link DistributedSystemArray} object.
     */
    function DistributedProcess(systemArray) {
        var _this = _super.call(this) || this;
        _this.system_array_ = systemArray;
        _this.name = "";
        // PERFORMANCE INDEX
        _this.resource = 1.0;
        _this.progress_list_ = new std.HashMap();
        _this.history_list_ = new std.HashMap();
        return _this;
    }
    /* ---------------------------------------------------------
        ACCESSORS
    --------------------------------------------------------- */
    /**
     * Identifier of {@link ParallelProcess} is its {@link name}.
     */
    DistributedProcess.prototype.key = function () {
        return this.name;
    };
    DistributedProcess.prototype.getSystemArray = function () {
        return this.system_array_;
    };
    /**
     * Get name, who represents and identifies this process.
     */
    DistributedProcess.prototype.getName = function () {
        return this.name;
    };
    /**
     * Get resource index.
     *
     * Get *resource index* that indicates how much this {@link DistributedProcess process} is heavy.
     *
     * If this {@link DistributedProcess process} does not have any	{@link Invoke} message had handled, then the
     * *resource index* will be ```1.0```, which means default and average value between all
     * {@link DistributedProcess} instances (that are belonged to a same {@link DistributedSystemArray} object).
     *
     * You can specify the *resource index* by yourself, but notice that, if the *resource index* is higher than
     * other {@link DistributedProcess} objects, then this {@link DistributedProcess process} will be ordered to
     * handle less processes than other {@link DistributedProcess} objects. Otherwise, the *resource index* is
     * lower than others, of course, much processes will be requested.
     *
     * - {@link setResource setResource()}
     * - {@link enforceResource enforceResource()}
     *
     * Unless {@link enforceResource enforceResource()} is called, This *resource index* is **revaluated** whenever
     * {@link sendData sendData()} is called.
     *
     * @return Resource index.
     */
    DistributedProcess.prototype.getResource = function () {
        return this.resource;
    };
    /**
     * Set resource index.
     *
     * Set *resource index* that indicates how much this {@link DistributedProcess process} is heavy. This
     * *resource index* can be **revaulated**.
     *
     * Note that, initial and average *resource index* of {@link DistributedProcess} objects are ```1.0```. If the
     * *resource index* is higher than other {@link DistributedProcess} objects, then this
     * {@link DistributedProcess} will be ordered to handle more processes than other {@link DistributedProcess}
     * objects. Otherwise, the *resource index* is lower than others, of course, less processes will be requested.
     *
     * Unlike {@link enforceResource}, configuring *resource index* by this {@link setResource} allows the
     * **revaluation**. This **revaluation** prevents wrong valuation from user. For example, you *mis-valuated* the
     * *resource index*. The {@link DistributedProcess process} is much heavier than any other, but you estimated it
     * to the lightest one. It looks like a terrible case that causes
     * {@link DistributedSystemArray entire distributed processing system} to be slower, however, don't mind. The
     * {@link DistributedProcess process} will the direct to the *propriate resource index* eventually with the
     * **revaluation**.
     *
     * - The **revaluation** is caused by the {@link sendData sendData()} method.
     *
     * @param val New resource index, but can be revaluated.
     */
    DistributedProcess.prototype.setResource = function (val) {
        this.resource = val;
        this.enforced_ = false;
    };
    /**
     * Enforce resource index.
     *
     * Enforce *resource index* that indicates how much heavy the {@link DistributedProcess process is}. The
     * *resource index* will be fixed, never be **revaluated**.
     *
     * Note that, initial and average *resource index* of {@link DistributedProcess} objects are ```1.0```. If the
     * *resource index* is higher than other {@link DistributedProcess} objects, then this
     * {@link DistributedProcess} will be ordered to handle more processes than other {@link DistributedProcess}
     * objects. Otherwise, the *resource index* is lower than others, of course, less processes will be requested.
     *
     * The difference between {@link setResource} and this {@link enforceResource} is allowing **revaluation** or not.
     * This {@link enforceResource} does not allow the **revaluation**. The *resource index* is clearly fixed and
     * never be changed by the **revaluation**. But you've to keep in mind that, you can't avoid the **mis-valuation**
     * with this {@link enforceResource}.
     *
     * For example, there's a {@link DistributedProcess process} much heavier than any other, but you
     * **mis-estimated** it to the lightest. In that case, there's no way. The
     * {@link DistributedSystemArray entire distributed processing system} will be slower by the **mis-valuation**.
     * By the reason, using {@link enforceResource}, it's recommended only when you can clearly certain the
     * *resource index*. If you can't certain the *resource index* but want to recommend, then use {@link setResource}
     * instead.
     *
     * @param val New resource index to be fixed.
     */
    DistributedProcess.prototype.enforceResource = function (val) {
        this.resource = val;
        this.enforced_ = true;
    };
    /**
     * @hidden
     */
    DistributedProcess.prototype._Compute_average_elapsed_time = function () {
        var sum = 0;
        for (var it = this.history_list_.begin(); !it.equals(this.history_list_.end()); it = it.next()) {
            var history_1 = it.second;
            var elapsed_time = history_1.computeElapsedTime() / history_1.getWeight();
            // THE SYSTEM'S PERFORMANCE IS 5. THE SYSTEM CAN HANDLE A PROCESS VERY QUICKLY
            //	AND ELAPSED TIME OF THE PROCESS IS 3 SECONDS
            //	THEN I CONSIDER THE ELAPSED TIME AS 15 SECONDS.
            sum += elapsed_time * history_1.getSystem().getPerformance();
        }
        return sum / this.history_list_.size();
    };
    DistributedProcess.prototype.sendData = function (invoke, weight) {
        if (weight === void 0) { weight = 1.0; }
        if (this.system_array_.empty() == true)
            return null;
        // ADD UID FOR ARCHIVING HISTORY
        var uid;
        if (invoke.has("_History_uid") == false) {
            // ISSUE UID AND ATTACH IT TO INVOKE'S LAST PARAMETER
            uid = ++this.system_array_["history_sequence_"];
            invoke.push_back(new InvokeParameter_1.InvokeParameter("_History_uid", uid));
        }
        else {
            // INVOKE MESSAGE ALREADY HAS ITS OWN UNIQUE ID
            //	- system_array_ IS A TYPE OF DistributedSystemArrayMediator. THE MESSAGE HAS COME FROM ITS MASTER
            //	- A Distributed HAS DISCONNECTED. THE SYSTEM SHIFTED ITS CHAIN TO ANOTHER SLAVE.
            uid = invoke.get("_History_uid").getValue();
            // FOR CASE 1. UPDATE HISTORY_SEQUENCE TO MAXIMUM
            this.system_array_["history_sequence_"] = uid;
            // FOR CASE 2. ERASE ORDINARY PROGRESSIVE HISTORY FROM THE DISCONNECTED
            this.progress_list_.erase(uid);
        }
        // ADD PROCESS NAME AND WEIGHT FOR MEDIATOR
        if (invoke.has("_Process_name") == false)
            invoke.push_back(new InvokeParameter_1.InvokeParameter("_Process_name", this.name));
        if (invoke.has("_Process_weight") == false)
            invoke.push_back(new InvokeParameter_1.InvokeParameter("_Process_weight", weight));
        else
            weight = invoke.get("_Process_name").getValue();
        // FIND THE MOST IDLE SYSTEM
        var idle_system = null;
        for (var i = 0; i < this.system_array_.size(); i++) {
            var system = this.system_array_.at(i);
            if (system["exclude_"] == true)
                continue; // BEING REMOVED SYSTEM
            if (idle_system == null || // NO IDLE SYSTEM YET
                (system["progress_list_"].empty() && system["history_list_"].empty()) || // NOTHING HAS REQUESTED
                system["progress_list_"].size() < idle_system["progress_list_"].size() || // LESS NUMBER OF PROGRESS
                (system["progress_list_"].size() == idle_system["progress_list_"].size() &&
                    system.getPerformance() > idle_system.getPerformance() // GREATER PERFORMANCE
                ) ||
                (system["progress_list_"].size() == idle_system["progress_list_"].size() &&
                    system.getPerformance() == idle_system.getPerformance() &&
                    system["history_list_"].size() < idle_system["history_list_"].size()) // LESS HISTORY
            )
                idle_system = system;
        }
        if (idle_system == null)
            throw new std.OutOfRange("No remote system to send data exists.");
        // ARCHIVE HISTORY ON PROGRESS_LIST (IN SYSTEM AND ROLE AT THE SAME TIME)
        var history = new DSInvokeHistory_1.DSInvokeHistory(idle_system, this, invoke, weight);
        this.progress_list_.emplace(uid, history);
        idle_system["progress_list_"].emplace(uid, std.make_pair(invoke, history));
        // SEND DATA
        idle_system.sendData(invoke);
        // RETURN THE IDLE SYSTEM, WHO SENT THE INVOKE MESSAGE.
        return idle_system;
    };
    /**
     * @hidden
     */
    DistributedProcess.prototype._Complete_history = function (history) {
        // ERASE FROM ORDINARY PROGRESS AND MIGRATE TO THE HISTORY
        this.progress_list_.erase(history.getUID());
        this.history_list_.emplace(history.getUID(), history);
    };
    /* ---------------------------------------------------------
        EXPORTERS
    --------------------------------------------------------- */
    /**
     * @inheritdoc
     */
    DistributedProcess.prototype.TAG = function () {
        return "process";
    };
    return DistributedProcess;
}(Entity_1.Entity));
exports.DistributedProcess = DistributedProcess;
//# sourceMappingURL=DistributedProcess.js.map