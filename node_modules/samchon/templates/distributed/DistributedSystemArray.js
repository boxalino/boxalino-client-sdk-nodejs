"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var std = require("tstl");
var ParallelSystemArray_1 = require("../parallel/ParallelSystemArray");
var DSInvokeHistory_1 = require("./DSInvokeHistory");
var sxml_1 = require("sxml");
/**
 * Master of Distributed Processing System.
 *
 * The {@link DistributedSystemArray} is an abstract class containing and managing remote distributed **slave** system
 * drivers, {@link DistributedSystem} objects. Within framework of network, {@link DistributedSystemArray} represents
 * your system, a **Master** of *Distributed Processing System* that requesting *distributed process* to **slave**
 * systems and the children {@link DistributedSystem} objects represent the remote **slave** systems, who is being
 * requested the *distributed processes*.
 *
 * You can specify this {@link DistributedSystemArray} class to be *a server accepting distributed clients* or
 * *a client connecting to distributed servers*. Even both of them is possible. Extends one of them below and overrides
 * abstract factory method(s) creating the child {@link DistributedSystem} object.
 *
 * - {@link DistributedClientArray}: A server accepting {@link DistributedSystem distributed clients}.
 * - {@link DistributedServerArray}: A client connecting to {@link DistributedServer distributed servers}.
 * - {@link DistributedServerClientArray}: Both of them. Accepts {@link DistributedSystem distributed clients} and
 *   connects to {@link DistributedServer distributed servers} at the same time.
 *
 * The {@link DistributedSystemArray} contains {@link DistributedProcess} objects directly. You can request a
 * **distributed process** through the {@link DistributedProcess} object. You can access the
 * {@link DistributedProcess} object(s) with those methods:
 *
 * - {@link hasProcess}
 * - {@link getProcess}
 * - {@link insertProcess}
 * - {@link eraseProcess}
 * - {@link getProcessMap}
 *
 * When you need the **distributed process**, call the {@link DistributedProcess.sendData} method. Then the
 * {@link DistributedProcess} will find the most idle {@link DistributedSystem} object who represents a distributed
 * **slave **system. The {@link Invoke} message will be sent to the most idle {@link DistributedSystem} object. When
 * the **distributed process** has completed, then {@link DistributedSystem.getPerformance performance index} and
 * {@link DistributedProcess.getResource resource index} of related objects will be revaluated.
 *
 * <a href="http://samchon.github.io/framework/images/design/ts_class_diagram/templates_distributed_system.png"
 *		  target="_blank">
    *	<img src="http://samchon.github.io/framework/images/design/ts_class_diagram/templates_distributed_system.png"
    *		 style="max-width: 100%" />
    * </a>
    *
    * #### Parallel Process
    * This {@link DistributedSystemArray} class is derived from the {@link ParallelSystemArray} class, so you can request
    * a **parallel process**, too.
    *
    * When you need the **parallel process**, then call one of them: {@link sendSegmentData} or {@link sendPieceData}.
    * When the **parallel process** has completed, {@link ParallelSystemArray} estimates each {@link ParallelSystem}'s
    * {@link ParallelSystem.getPerformance performance index} basis on their execution time. Those performance indices will
    * be reflected to the next **parallel process**, how much pieces to allocate to each {@link ParallelSystem}.
    *
    * #### Proxy Pattern
    * This class {@link DistributedSystemArray} is derived from the {@link ExternalSystemArray} class. Thus, you can take
    * advantage of the *Proxy Pattern* in the {@link DistributedSystemArray} class. If a process to request is not the
    * *parallel process* (to be distrubted to all slaves), but the **exclusive process** handled in a system, then it
    * may better to utilizing the *Proxy Pattern*:
    *
    * The {@link ExternalSystemArray} class can use *Proxy Pattern*. In framework within user, which
    * {@link ExternalSystem external system} is connected with {@link ExternalSystemArray this system}, it's not
    * important. Only interested in user's perspective is *which can be done*.
    *
    * By using the *logical proxy*, user dont't need to know which {@link ExternalSystemRole role} is belonged
    * to which {@link ExternalSystem system}. Just access to a role directly from {@link ExternalSystemArray.getRole}.
    * Sends and receives {@link Invoke} message via the {@link ExternalSystemRole role}.
    *
    * <ul>
    *	<li>
    *		{@link ExternalSystemRole} can be accessed from {@link ExternalSystemArray} directly, without inteferring
    *		from {@link ExternalSystem}, with {@link ExternalSystemArray.getRole}.
    *	</li>
    *	<li>
    *		When you want to send an {@link Invoke} message to the belonged {@link ExternalSystem system}, just call
    *		{@link ExternalSystemRole.sendData ExternalSystemRole.sendData()}. Then, the message will be sent to the
    *		external system.
    *	</li>
    *	<li> Those strategy is called *Proxy Pattern*. </li>
    * </ul>
    *
    * @handbook [Templates - Distributed System](https://github.com/samchon/framework/wiki/TypeScript-Templates-Distributed_System)
    * @author Jeongho Nam <http://samchon.org>
    */
var DistributedSystemArray = /** @class */ (function (_super) {
    __extends(DistributedSystemArray, _super);
    /* ---------------------------------------------------------
        CONSTRUCTORS
    --------------------------------------------------------- */
    /**
     * Default Constructor.
     */
    function DistributedSystemArray() {
        var _this = _super.call(this) || this;
        // CREATE ROLE MAP AND ENROLL COLLECTION EVENT LISTENRES
        _this.process_map_ = new std.HashMap();
        return _this;
    }
    /**
     * @inheritdoc
     */
    DistributedSystemArray.prototype.construct = function (xml) {
        //--------
        // CONSTRUCT ROLES
        //--------
        // CLEAR ORDINARY ROLES
        this.process_map_.clear();
        // CREATE ROLES
        if (xml.has("processes") == true && xml.get("processes").front().has("process") == true) {
            var role_xml_list = xml.get("processes").front().get("process");
            for (var i = 0; i < role_xml_list.size(); i++) {
                var role_xml = role_xml_list.at(i);
                // CONSTRUCT ROLE FROM XML
                var process = this.createProcess(role_xml);
                process.construct(role_xml);
                // AND INSERT TO ROLE_MAP
                this.process_map_.emplace(process.getName(), process);
            }
        }
        //--------
        // CONSTRUCT SYSTEMS
        //--------
        _super.prototype.construct.call(this, xml);
    };
    /* ---------------------------------------------------------
        ACCESSORS
    --------------------------------------------------------- */
    /**
     * Get process map.
     *
     * Gets an {@link HashMap} containing {@link DistributedProcess} objects with their *key*.
     *
     * @return An {@link HasmMap> containing pairs of string and {@link DistributedProcess} object.
     */
    DistributedSystemArray.prototype.getProcessMap = function () {
        return this.process_map_;
    };
    /**
     * Test whether the process exists.
     *
     * @param name Name, identifier of target {@link DistributedProcess process}.
     *
     * @return Whether the process has or not.
     */
    DistributedSystemArray.prototype.hasProcess = function (name) {
        return this.process_map_.has(name);
    };
    /**
     * Get a process.
     *
     * @param name Name, identifier of target {@link DistributedProcess process}.
     *
     * @return The specified process.
     */
    DistributedSystemArray.prototype.getProcess = function (name) {
        return this.process_map_.get(name);
    };
    /**
     * Insert a process.
     *
     * @param process A process to be inserted.
     * @return Success flag.
     */
    DistributedSystemArray.prototype.insertProcess = function (process) {
        return this.process_map_.emplace(process.getName(), process).second;
    };
    /**
     * Erase a process.
     *
     * @param name Name, identifier of target {@link DistributedProcess process}.
     */
    DistributedSystemArray.prototype.eraseProcess = function (name) {
        var prev_size = this.process_map_.size();
        return (this.process_map_.erase(name) != prev_size);
    };
    /* ---------------------------------------------------------
        HISTORY HANDLER - PERFORMANCE ESTIMATION
    --------------------------------------------------------- */
    /**
     * @hidden
     */
    DistributedSystemArray.prototype._Complete_history = function (history) {
        if (history instanceof DSInvokeHistory_1.DSInvokeHistory) {
            //--------
            // DistributedProcess's history -> DSInvokeHistory
            //--------
            // NO ROLE, THEN FAILED TO COMPLETE
            if (history.getProcess() == null)
                return false;
            // ESTIMATE PERFORMANCE INDEXES
            this.estimate_system_performance(history); // ESTIMATE SYSTEMS' INDEX
            this.estimate_process_resource(history); // ESTIMATE PROCESS' RESOURCE
            // AT LAST, NORMALIZE PERFORMANCE INDEXES OF ALL SYSTEMS AND ROLES
            this._Normalize_performance();
            return true;
        }
        else {
            // ParallelSystem's history -> PRInvokeHistory
            return _super.prototype._Complete_history.call(this, history);
        }
    };
    /**
     * @hidden
     */
    DistributedSystemArray.prototype.estimate_process_resource = function (history) {
        var process = history.getProcess();
        if (process["enforced_"] == true)
            return; // THE RESOURCE INDEX IS ENFORCED. DO NOT PERMIT REVALUATION
        var average_elapsed_time_of_others = 0;
        var denominator = 0;
        // COMPUTE AVERAGE ELAPSED TIME
        for (var it = this.process_map_.begin(); !it.equals(this.process_map_.end()); it = it.next()) {
            var my_process = it.second;
            if (my_process == history.getProcess() || my_process["history_list_"].empty() == true)
                continue;
            average_elapsed_time_of_others += my_process["_Compute_average_elapsed_time"]() * my_process.getResource();
            denominator++;
        }
        // COMPARE WITH THIS HISTORY'S ELAPSED TIME
        if (denominator != 0) {
            // DIVE WITH DENOMINATOR
            average_elapsed_time_of_others /= denominator;
            // DEDUCT NEW PERFORMANCE INDEX BASED ON THE EXECUTION TIME
            //	- ROLE'S PERFORMANCE MEANS; HOW MUCH TIME THE ROLE NEEDS
            //	- ELAPSED TIME IS LONGER, THEN PERFORMANCE IS HIGHER
            var elapsed_time = history.computeElapsedTime() / history.getWeight(); // CONSIDER WEIGHT
            var new_resource = elapsed_time / average_elapsed_time_of_others; // NEW PERFORMANCE
            // DEDUCT RATIO TO REFLECT THE NEW PERFORMANCE INDEX -> MAXIMUM: 15%
            var ordinary_ratio = void 0;
            if (process["history_list_"].size() < 2)
                ordinary_ratio = .15;
            else
                ordinary_ratio = Math.min(.85, 1.0 / (process["history_list_"].size() - 1.0));
            // DEFINE NEW PERFORMANCE
            process.setResource((process.getResource() * ordinary_ratio)
                + (new_resource * (1 - ordinary_ratio)));
        }
    };
    /**
     * @hidden
     */
    DistributedSystemArray.prototype.estimate_system_performance = function (history) {
        var system = history.getSystem();
        if (system["enforced_"] == true)
            return; // THE PERFORMANCE INDEX IS ENFORCED. IT DOESN'T PERMIT REVALUATION
        var average_elapsed_time_of_others = 0;
        var denominator = 0;
        // COMPUTE AVERAGE ELAPSED TIME
        for (var i = 0; i < this.size(); i++) {
            var system_1 = this.at(i);
            var avg = system_1["_Compute_average_elapsed_time"]();
            if (avg == -1)
                continue;
            average_elapsed_time_of_others += avg;
            denominator++;
        }
        // COMPARE WITH THIS HISTORY'S ELAPSED TIME
        if (denominator != 0) {
            // DIVE WITH DENOMINATOR
            average_elapsed_time_of_others /= denominator;
            // DEDUCT NEW PERFORMANCE INDEX BASED ON THE EXECUTION TIME
            //	- SYSTEM'S PERFORMANCE MEANS; HOW FAST THE SYSTEM IS
            //	- ELAPSED TIME IS LOWER, THEN PERFORMANCE IS HIGHER
            var elapsed_time = history.computeElapsedTime() / history.getWeight(); // CONSIDER WEIGHT
            var new_performance = average_elapsed_time_of_others / elapsed_time; // NEW PERFORMANCE
            // DEDUCT RATIO TO REFLECT THE NEW PERFORMANCE INDEX -> MAXIMUM: 30%
            var ordinary_ratio = void 0;
            if (system["history_list_"].size() < 2)
                ordinary_ratio = .3;
            else
                ordinary_ratio = Math.min(0.7, 1.0 / (system["history_list_"].size() - 1.0));
            // DEFINE NEW PERFORMANCE
            system.setPerformance((system.getPerformance() * ordinary_ratio)
                + (new_performance * (1 - ordinary_ratio)));
        }
    };
    /**
     * @hidden
     */
    DistributedSystemArray.prototype._Normalize_performance = function () {
        // NORMALIZE SYSTEMS' PERFORMANCE INDEXES
        _super.prototype._Normalize_performance.call(this);
        // COMPUTE AVERAGE
        var average = 0.0;
        var denominator = 0;
        for (var it = this.process_map_.begin(); !it.equals(this.process_map_.end()); it = it.next()) {
            var process = it.second;
            if (process["enforced_"] == true)
                continue; // THE RESOURCE INDEX IS ENFORCED. DO NOT PERMIT REVALUATION
            average += process.getResource();
            denominator++;
        }
        average /= denominator;
        // DIVIDE FROM THE AVERAGE
        for (var it = this.process_map_.begin(); !it.equals(this.process_map_.end()); it = it.next()) {
            var process = it.second;
            if (process["enforced_"] == true)
                continue; // THE RESOURCE INDEX IS ENFORCED. DO NOT PERMIT REVALUATION
            process.setResource(process.getResource() / average);
        }
    };
    /* ---------------------------------------------------------
        EXPORTERS
    --------------------------------------------------------- */
    /**
     * @inheritdoc
     */
    DistributedSystemArray.prototype.toXML = function () {
        var xml = _super.prototype.toXML.call(this);
        if (this.process_map_.empty() == true)
            return xml;
        var processes_xml = new sxml_1.XML();
        {
            processes_xml.setTag("processes");
            for (var it = this.process_map_.begin(); !it.equals(this.process_map_.end()); it = it.next())
                processes_xml.push(it.second.toXML());
        }
        xml.push(processes_xml);
        return xml;
    };
    return DistributedSystemArray;
}(ParallelSystemArray_1.ParallelSystemArray));
exports.DistributedSystemArray = DistributedSystemArray;
//# sourceMappingURL=DistributedSystemArray.js.map