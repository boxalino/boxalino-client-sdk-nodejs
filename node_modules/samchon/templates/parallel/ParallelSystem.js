"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var std = require("tstl");
var ExternalSystem_1 = require("../external/ExternalSystem");
var PRInvokeHistory_1 = require("./PRInvokeHistory");
var Invoke_1 = require("../../protocol/invoke/Invoke");
var InvokeParameter_1 = require("../../protocol/invoke/InvokeParameter");
/**
 * A driver for a parallel slave system.
 *
 * The {@link ParallelSystem} is an abstract class represents a **slave** system in *Parallel Processing System*,
 * connected with this **master** system. This {@link ParallelSystem} takes full charge of network communication with
 * the remote, parallel **slave** system has connected.
 *
 * When a *parallel process* is requested (by {@link ParallelSystemArray.sendSegmentData} or
 * {@link ParallelSystemArray.sendPieceData}), the number of pieces to be allocated to a {@link ParallelSystem} is
 * turn on its {@link getPerformance performance index}. Higher {@link getPerformance performance index}, then
 * more pieces are requested. The {@link getPerformance performance index} is revaluated whenever a *parallel process*
 * has completed, basic on the execution time and number of pieces. You can sugguest or enforce the
 * {@link getPerformance performance index} with {@link setPerformance} or {@link enforcePerformance}.
 *
 * <a href="http://samchon.github.io/framework/images/design/ts_class_diagram/templates_parallel_system.png"
 *		  target="_blank">
    *	<img src="http://samchon.github.io/framework/images/design/ts_class_diagram/templates_parallel_system.png"
    *		 style="max-width: 100%" />
    * </a>
    *
    * #### Bridge & Proxy Pattern
    * This class {@link ParallelSystem} is derived from the {@link ExternalSystem} class. Thus, you can take advantage
    * of the *Bridge & Proxy Pattern* in this {@link ParallelSystem} class. If a process to request is not the
    * *parallel process* (to be distrubted to all slaves), but the **exclusive process** handled in a system, then it
    * may better to utilizing the *Bridge & Proxy Pattern*:
    *
    * The {@link ExternalSystem} class can be a *bridge* for *logical proxy*. In framework within user,
    * which {@link ExternalSystem external system} is connected with {@link ExternalSystemArray this system}, it's not
    * important. Only interested in user's perspective is *which can be done*.
    *
    * By using the *logical proxy*, user dont't need to know which {@link ExternalSystemRole role} is belonged
    * to which {@link ExternalSystem system}. Just access to a role directly from {@link ExternalSystemArray.getRole}.
    * Sends and receives {@link Invoke} message via the {@link ExternalSystemRole role}.
    *
    * <ul>
    *	<li>
    *		{@link ExternalSystemRole} can be accessed from {@link ExternalSystemArray} directly, without inteferring
    *		from {@link ExternalSystem}, with {@link ExternalSystemArray.getRole}.
    *	</li>
    *	<li>
    *		When you want to send an {@link Invoke} message to the belonged {@link ExternalSystem system}, just call
    *		{@link ExternalSystemRole.sendData ExternalSystemRole.sendData()}. Then, the message will be sent to the
    *		external system.
    *	</li>
    *	<li> Those strategy is called *Bridge Pattern* and *Proxy Pattern*. </li>
    * </ul>
    *
    * @handbook [Templates - Parallel System](https://github.com/samchon/framework/wiki/TypeScript-Templates-Parallel_System)
    * @author Jeongho Nam <http://samchon.org>
    */
var ParallelSystem = /** @class */ (function (_super) {
    __extends(ParallelSystem, _super);
    function ParallelSystem(systemArray, communicator) {
        if (communicator === void 0) { communicator = null; }
        var _this = _super.call(this, systemArray, communicator) || this;
        // HIDDEN MEMBERS
        _this.progress_list_ = new std.HashMap();
        _this.history_list_ = new std.HashMap();
        _this.enforced_ = false;
        _this.exclude_ = false;
        // PERFORMANCE INDEX
        _this.performance = 1.0;
        return _this;
    }
    /**
     * Default Destructor.
     *
     * This {@link destructor destructor()} method is called when the {@link ParallelSystem} object is destructed and
     * the {@link ParallelSystem} object is destructed when connection with the remote system is closed or this
     * {@link ParallelSystem} object is {@link ParallelSystemArray.erase erased} from its parent
     * {@link ParallelSystemArray} object.
     *
     * You may think if there're some *parallel processes* have requested but not completed yet, then it would be a
     * critical problem because the *parallel processes* will not complete forever. Do not worry. The critical problem
     * does not happen. After the destruction, the remained *parallel processes* will be shifted to and proceeded in
     * other {@link ParallelSystem} objects.
     *
     * Note that, don't call this {@link destructor destructor()} method by yourself. It must be called automatically
     * by those *destruction* cases. Also, if your derived {@link ParallelSystem} class has something to do on the
     * *destruction*, then overrides this {@link destructor destructor()} method and defines the something to do.
     * Overriding this {@link destructor destructor()}, don't forget to calling ```super.destructor();``` on tail.
     *
     * ```typescript
     * class SomeSystem extends ExternalSystem
     * {
     *     protected destructor(): void
     *     {
     *         // DO SOMETHING
     *         this.do_something();
     *
     *         // CALL SUPER.DESTRUCTOR() ON TAIL. DON'T FORGET THIS
     *         super.destructor();
     *     }
     * }
     * ```
     */
    ParallelSystem.prototype.destructor = function () {
        this.exclude_ = true;
        for (var it = this.progress_list_.begin(); !it.equals(this.progress_list_.end()); it = it.next()) {
            // AN INVOKE AND HISTORY HAD PROGRESSED
            var invoke = it.second.first;
            var history_1 = it.second.second;
            this._Send_back_history(invoke, history_1);
        }
        _super.prototype.destructor.call(this);
    };
    ParallelSystem.prototype.getSystemArray = function () {
        return this["system_array_"];
    };
    /**
     * Get performance index.
     *
     * Get *performance index* that indicates how much fast the remote system is.
     *
     * If this {@link ParallelSystem parallel system} does not have any {@link Invoke} message had handled, then the
     * *performance index* will be ```1.0```, which means default and average value between all {@link ParallelSystem}
     * instances (that are belonged to a same {@link ParallelSystemArray} object).
     *
     * You can specify this *performance index* by yourself but notice that, if the *performance index* is higher
     * than other {@link ParallelSystem} objects, then this {@link ParallelSystem parallel system} will be ordered to
     * handle more processes than other {@link ParallelSystem} objects. Otherwise, the *performance index* is lower
     * than others, of course, less processes will be delivered.
     *
     * - {@link setPerformance setPerformance()}
     * - {@link enforcePerformance enforcePerformance()}
     *
     * Unless {@link enforcePerformance enforcePerformance()} is called, This *performance index* is **revaluated**
     * whenever user calls one of them below.
     *
     * - {@link ParallelSystemArray.sendSegmentData ParallelSystemArray.sendSegmentData()}
     * - {@link ParallelSystemArray.sendPieceData ParallelSystemArray.sendPieceData()}
     * - {@link DistributedProcess.sendData DistributedProcess.sendData()}.
     *
     * @return Performance index.
     */
    ParallelSystem.prototype.getPerformance = function () {
        return this.performance;
    };
    /**
     * Set performance index.
     *
     * Set *performance index* that indicates how much fast the remote system is. This *performance index* can be
     * **revaulated**.
     *
     * Note that, initial and average *performance index* of {@link ParallelSystem} objects are ```1.0```. If the
     * *performance index* is higher than other {@link ParallelSystem} objects, then this {@link ParallelSystem} will
     * be ordered to handle more processes than other {@link ParallelSystem} objects. Otherwise, the
     * *performance index* is lower than others, of course, less processes will be delivered.
     *
     * Unlike {@link enforcePerformance}, configuring *performance index* by this {@link setPerformance} allows
     * **revaluation**. This **revaluation** prevents wrong valuation from user. For example, you *mis-valuated* the
     * *performance index*. The remote system is much faster than any other, but you estimated it to the slowest one.
     * It looks like a terrible case that causes {@link ParallelSystemArray entire parallel systems} to be slower,
     * however, don't mind. The system will direct to the *propriate performance index* eventually with the
     * **revaluation** by following methods.
     *
     * - {@link ParallelSystemArray.sendSegmentData ParallelSystemArray.sendSegmentData()}
     * - {@link ParallelSystemArray.sendPieceData ParallelSystemArray.sendPieceData()}
     * - {@link DistributedProcess.sendData DistributedProcess.sendData()}.
     *
     * @param val New performance index, but can be revaluated.
     */
    ParallelSystem.prototype.setPerformance = function (val) {
        this.performance = val;
        this.enforced_ = false;
    };
    /**
     * Enforce performance index.
     *
     * Enforce *performance index* that indicates how much fast the remote system is. The *performance index* will be
     * fixed, never be **revaluated**.
     *
     * Note that, initial and average *performance index* of {@link ParallelSystem} objects are ```1.0```. If the
     * *performance index* is higher than other {@link ParallelSystem} objects, then this {@link ParallelSystem} will
     * be ordered to handle more processes than other {@link ParallelSystem} objects. Otherwise, the
     * *performance index* is lower than others, of course, less processes will be delivered.
     *
     * The difference between {@link setPerformance} and this {@link enforcePerformance} is allowing **revaluation**
     * or not. This {@link enforcePerformance} does not allow the **revaluation**. The *performance index* is clearly
     * fixed and never be changed by the **revaluation**. But you've to keep in mind that, you can't avoid the
     * **mis-valuation** with this {@link enforcePerformance}.
     *
     * For example, there's a remote system much faster than any other, but you **mis-estimated** it to the slowest.
     * In that case, there's no way. The {@link ParallelSystemArray entire parallel systems} will be slower by the
     * **mis-valuation**. By the reason, using {@link enforcePerformance}, it's recommended only when you can clearly
     * certain the *performance index*. If you can't certain the *performance index* but want to recommend, then use
     * {@link setPerformance} instead.
     *
     * @param val New performance index to be fixed.
     */
    ParallelSystem.prototype.enforcePerformance = function (val) {
        this.performance = val;
        this.enforced_ = true;
    };
    /* ---------------------------------------------------------
        MESSAGE CHAIN
    --------------------------------------------------------- */
    /**
     * @hidden
     */
    ParallelSystem.prototype._Send_piece_data = function (invoke, first, last) {
        // DUPLICATE INVOKE AND ATTACH PIECE INFO
        var my_invoke = new Invoke_1.Invoke(invoke.getListener());
        {
            my_invoke.assign(invoke.begin(), invoke.end());
            my_invoke.push_back(new InvokeParameter_1.InvokeParameter("_Piece_first", first));
            my_invoke.push_back(new InvokeParameter_1.InvokeParameter("_Piece_last", last));
        }
        // REGISTER THE UID AS PROGRESS
        var history = new PRInvokeHistory_1.PRInvokeHistory(my_invoke);
        this.progress_list_.emplace(history.getUID(), // KEY: UID
        std.make_pair(my_invoke, history) // VALUE: PAIR OF INVOKE AND ITS HISTORY
        );
        // SEND DATA
        this.sendData(my_invoke);
    };
    /**
     * @hidden
     */
    ParallelSystem.prototype._Reply_data = function (invoke) {
        if (invoke.getListener() == "_Report_history") {
            this._Report_history(invoke.front().getValue());
        }
        else if (invoke.getListener() == "_Send_back_history") {
            var uid = invoke.front().getValue();
            var it = this.progress_list_.find(uid);
            if (it.equals(this.progress_list_.end()) == true)
                return;
            this._Send_back_history(it.second.first, it.second.second);
        }
        else
            this.replyData(invoke);
    };
    /**
     * @hidden
     */
    ParallelSystem.prototype._Report_history = function (xml) {
        //--------
        // CONSTRUCT HISTORY
        //--------
        var history = new PRInvokeHistory_1.PRInvokeHistory();
        history.construct(xml);
        // IF THE HISTORY IS NOT EXIST IN PROGRESS, THEN TERMINATE REPORTING
        var progress_it = this.progress_list_.find(history.getUID());
        if (progress_it.equals(this.progress_list_.end()) == true)
            return;
        // ARCHIVE FIRST AND LAST INDEX
        history["first"] = progress_it.second.second.getFirst();
        history["last"] = progress_it.second.second.computeSize();
        // ERASE FROM ORDINARY PROGRESS AND MIGRATE TO THE HISTORY
        this.progress_list_.erase(progress_it);
        this.history_list_.emplace(history.getUID(), history);
        // NOTIFY TO THE MANAGER, SYSTEM_ARRAY
        this.getSystemArray()["_Complete_history"](history);
    };
    /**
     * @hidden
     */
    ParallelSystem.prototype._Send_back_history = function (invoke, history) {
        if (history instanceof PRInvokeHistory_1.PRInvokeHistory) {
            // REMOVE UID AND FIRST, LAST INDEXES
            invoke.erase(std.remove_if(invoke.begin(), invoke.end(), function (param) {
                return param.getName() == "_History_uid"
                    || param.getName() == "_Piece_first"
                    || param.getName() == "_Piece_last";
            }), invoke.end());
            // RE-SEND (DISTRIBUTE) THE PIECE TO OTHER SLAVES
            this.getSystemArray().sendPieceData(invoke, history.getFirst(), history.getLast());
        }
        // ERASE FROM THE PROGRESS LIST
        this.progress_list_.erase(history.getUID());
    };
    return ParallelSystem;
}(ExternalSystem_1.ExternalSystem));
exports.ParallelSystem = ParallelSystem;
//# sourceMappingURL=ParallelSystem.js.map