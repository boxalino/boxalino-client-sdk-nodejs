"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var std = require("tstl");
var SlaveSystem_1 = require("../slave/SlaveSystem");
var DistributedSystemArrayMediator_1 = require("../distributed/DistributedSystemArrayMediator");
var Invoke_1 = require("../../protocol/invoke/Invoke");
var InvokeHistory_1 = require("../slave/InvokeHistory");
/**
 * A mediator, the master driver.
 *
 * The {@link MediatorSystem} is an abstract class helping {@link ParallelSystemArrayMediator} can be a **slave**
 * system. The {@link MediatorSystem} interacts and communicates with the **master** system as a role of **slave**.
 *
 * This {@link MediatorSystem} object is created in {@link ParallelSystemArrayMediator.createMediator}. Override the
 * method and return one of them, which are derived from this {@link MediatorSystem} class, considering which
 * type and protocol the **master** system follows:
 *
 * - A client slave connecting to master server:
 *   - {@link MediatorClient}
 *   - {@link MediatorWebClient}
 *   - {@link MediatorSharedWorkerClient}
 * - A server slave accepting master client:
 *   - {@link MediatorServer}
 *   - {@link MediatorWebServer}
 *   - {@link MediatorDedicatedWorkerServer}
 *   - {@link MediatorSharedWorkerServer}
 *
 * When the **master** orders a *parallel process* to this **slave**, then the {@link MediatorSystem} delivers the
 * *parallel process* to its parent {@link ParallelSystemArrayMediator} object. The
 * {@link ParallelSystemArrayMediator} object distributes the *parallel process* to its slaves system,
 * {@link ParallelSystem} objects. When the *parallel process* has completed, then {@link MediatorSystem} reports the
 * result to its **master**.
 *
 * <a href="http://samchon.github.io/framework/images/design/ts_class_diagram/templates_parallel_system.png"
 *		  target="_blank">
    *	<img src="http://samchon.github.io/framework/images/design/ts_class_diagram/templates_parallel_system.png"
    *		 style="max-width: 100%" />
    * </a>
    *
    * @handbook [Templates - Parallel System](https://github.com/samchon/framework/wiki/TypeScript-Templates-Parallel_System),
    *			 [Distributed System](https://github.com/samchon/framework/wiki/TypeScript-Templates-Distributed_System)
    * @author Jeongho Nam <http://samchon.org>
    */
var MediatorSystem = /** @class */ (function (_super) {
    __extends(MediatorSystem, _super);
    function MediatorSystem(systemArray) {
        var _this = _super.call(this) || this;
        _this.system_array_ = systemArray;
        _this.progress_list_ = new std.HashMap();
        return _this;
    }
    MediatorSystem.prototype.getSystemArray = function () {
        return this.system_array_;
    };
    /* ---------------------------------------------------------
        MESSAGE CHAIN
    --------------------------------------------------------- */
    /**
     * @hidden
     */
    MediatorSystem.prototype._Complete_history = function (uid) {
        // NO SUCH HISTORY; THE PROCESS HAD DONE ONLY IN THIS MEDIATOR LEVEL.
        if (this.progress_list_.has(uid) == false)
            return;
        // COMPLETE THE HISTORY
        var history = this.progress_list_.get(uid);
        var start_time = null;
        var end_time = null;
        // DETERMINE WHEN STARTED AND COMPLETED TIME
        for (var i = 0; i < this.system_array_.size(); i++) {
            var system = this.system_array_.at(i);
            var it = system["history_list_"].find(uid);
            if (it.equals(system["history_list_"].end()) == true)
                continue;
            var my_history = it.second;
            if (start_time == null || my_history.getStartTime() < start_time)
                start_time = my_history.getStartTime();
            if (end_time == null || my_history.getEndTime() > end_time)
                end_time = my_history.getEndTime();
        }
        history["start_time_"] = start_time;
        history["end_time_"] = end_time;
        // ERASE THE HISTORY ON PROGRESS LIST
        this.progress_list_.erase(uid);
        // REPORT THE HISTORY TO MASTER
        this.sendData(history.toInvoke());
    };
    /**
     * @hidden
     */
    MediatorSystem.prototype._Reply_data = function (invoke) {
        if (invoke.has("_History_uid") == true) {
            // INIT HISTORY OBJECT
            var history_1 = new InvokeHistory_1.InvokeHistory(invoke);
            if (this.system_array_.empty() == true) {
                // NO BELONGED SLAVE, THEN SEND BACK
                this.sendData(new Invoke_1.Invoke("_Send_back_history", history_1.getUID()));
                return;
            }
            // REGISTER THIS PROCESS ON HISTORY LIST
            this.progress_list_.emplace(history_1.getUID(), history_1);
            if (invoke.has("_Piece_first") == true) {
                // PARALLEL PROCESS
                var first = invoke.get("_Piece_first").getValue();
                var last = invoke.get("_Piece_last").getValue();
                invoke.erase(invoke.end().advance(-2), invoke.end());
                this.system_array_.sendPieceData(invoke, first, last);
            }
            else if (this.system_array_ instanceof DistributedSystemArrayMediator_1.DistributedSystemArrayMediator
                && invoke.has("_Process_name") == true) {
                // FIND THE MATCHED ROLE
                var process_name = invoke.get("_Process_name").getValue();
                if (this.system_array_.hasProcess(process_name) == false)
                    return;
                // SEND DATA VIA THE ROLE
                var process = this.system_array_.getProcess(process_name);
                process.sendData(invoke);
            }
        }
        else
            this.replyData(invoke);
    };
    /**
     * @inheritdoc
     */
    MediatorSystem.prototype.replyData = function (invoke) {
        this.system_array_.sendData(invoke);
    };
    return MediatorSystem;
}(SlaveSystem_1.SlaveSystem));
exports.MediatorSystem = MediatorSystem;
//# sourceMappingURL=MediatorSystem.js.map