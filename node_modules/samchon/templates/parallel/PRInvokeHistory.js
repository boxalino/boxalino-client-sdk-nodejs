"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var InvokeHistory_1 = require("../slave/InvokeHistory");
/**
 * History of an {@link Invoke} message.
 *
 * The {@link PRInvokeHistory} is a class archiving history log of an {@link Invoke} message which requests the
 * *parallel process*, created whenever {@link ParallelSystemArray.sendSegmentData} or
 * {@link ParallelSystemArray.sendSegmentData} is called.
 *
 * When the *parallel process* has completed, then {@link complete complete()} is called and the *elapsed time* is
 * determined. The elapsed time is utilized for computation of {@link ParallelSystem.getPerformance performance index}
 * of each {@link ParallelSystem parallel slave system}.
 *
 * <a href="http://samchon.github.io/framework/images/design/ts_class_diagram/templates_parallel_system.png"
 *		  target="_blank">
    *	<img src="http://samchon.github.io/framework/images/design/ts_class_diagram/templates_parallel_system.png"
    *		 style="max-width: 100%" />
    * </a>
    *
    * @handbook [Templates - Parallel System](https://github.com/samchon/framework/wiki/TypeScript-Templates-Parallel_System)
    * @author Jeongho Nam <http://samchon.org>
    */
var PRInvokeHistory = /** @class */ (function (_super) {
    __extends(PRInvokeHistory, _super);
    function PRInvokeHistory(invoke) {
        if (invoke === void 0) { invoke = null; }
        var _this = _super.call(this, invoke) || this;
        if (invoke == null) {
            _this.first = 0;
            _this.last = 0;
        }
        else {
            _this.first = invoke.get("_Piece_first").getValue();
            _this.last = invoke.get("_Piece_last").getValue();
        }
        return _this;
    }
    /**
     * Get initial piece's index.
     *
     * Returns initial piece's index in the section of requested *parallel process*.
     *
     * @return The initial index.
     */
    PRInvokeHistory.prototype.getFirst = function () {
        return this.first;
    };
    /**
     * Get final piece's index.
     *
     * Returns initial piece's index in the section of requested *parallel process*. The range used is
     * [*first*, *last*), which contains all the pieces' indices between *first* and *last*, including the piece
     * pointed by index *first*, but not the piece pointed by the index *last*.
     *
     * @return The final index.
     */
    PRInvokeHistory.prototype.getLast = function () {
        return this.last;
    };
    /**
     * Compute number of allocated pieces.
     */
    PRInvokeHistory.prototype.computeSize = function () {
        return this.last - this.first;
    };
    return PRInvokeHistory;
}(InvokeHistory_1.InvokeHistory));
exports.PRInvokeHistory = PRInvokeHistory;
//# sourceMappingURL=PRInvokeHistory.js.map