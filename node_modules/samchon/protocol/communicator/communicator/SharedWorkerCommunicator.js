"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var _CommunicatorBase_1 = require("./_CommunicatorBase");
/**
 * A communicator for shared worker.
 *
 * {@link SharedWorkerCommunicator} is an abstract class for communication between SharedWorker and Web-browser. This
 * {@link SharedWorkerCommunicator} is specified to {@link SharedWorkerServerConnector} and
 * {@link SharedWorkerClientDriver} whether the remote system is a server (that my system is connecting to) or a client
 * (a client conneting to to my server).
 *
 * Note that, SharedWorker is a conception only existed in web-browser. This {@link SharedWorkerCommunicator} is not
 * supported in NodeJS. Only web-browser environment can utilize this {@link SharedWorkerCommunicator}.
 *
 * #### Why SharedWorker be a server?
 * SharedWorker, it allows only an instance (process) to be created whether the SharedWorker is declared in a browser
 * or multiple browsers. To integrate them, messages are being sent and received. Doesn't it seem like a relationship
 * between a server and clients? Thus, Samchon Framework consider the SharedWorker as a server and browsers as
 * clients.
 *
 * The class {@link SharedWorkerCommunicator} is designed make such relationship. From now on, SharedWorker is a
 * {@link SharedWorkerServer server} and {@link SharedWorkerServerConnector browsers} are clients. Integrate the
 * server and clients with this {@link SharedWorkerCommunicator}.
 *
 * #### [Inherited] {@link ICommunicator}
 * @copydoc ICommunicator
 */
var SharedWorkerCommunicator = /** @class */ (function (_super) {
    __extends(SharedWorkerCommunicator, _super);
    function SharedWorkerCommunicator() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /* ---------------------------------------------------------
        CONSTRUCTORS
    --------------------------------------------------------- */
    // using super::constructor
    /**
     * @inheritdoc
     */
    SharedWorkerCommunicator.prototype.close = function () {
        this.connected_ = false;
        this.port_.close();
        if (this.onClose != null)
            this.onClose();
    };
    /* ---------------------------------------------------------
        INVOKE MESSAGE I/O
    --------------------------------------------------------- */
    /**
     * @inheritdoc
     */
    SharedWorkerCommunicator.prototype.sendData = function (invoke) {
        this.port_.postMessage(invoke.toXML().toString());
        for (var i = 0; i < invoke.size(); i++)
            if (invoke.at(i).getType() == "ByteaArray")
                this.port_.postMessage(invoke.at(i).getValue());
    };
    /**
     * @hidden
     */
    SharedWorkerCommunicator.prototype._Handle_message = function (event) {
        if (this._Is_binary_invoke() == false)
            this._Handle_string(event.data);
        else
            this._Handle_binary(event.data);
    };
    return SharedWorkerCommunicator;
}(_CommunicatorBase_1._CommunicatorBase));
exports.SharedWorkerCommunicator = SharedWorkerCommunicator;
//# sourceMappingURL=SharedWorkerCommunicator.js.map