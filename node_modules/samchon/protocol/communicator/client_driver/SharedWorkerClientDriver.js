"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var SharedWorkerCommunicator_1 = require("../communicator/SharedWorkerCommunicator");
/**
 * Communicator with remote web-browser.
 *
 * {@link SharedWorkerClientDriver} is a class taking full charge of network communication with web browsers. This
 * {@link SharedWorkerClientDriver} object is always created by {@link SharedWorkerServer} class. When you got this
 * {@link SharedWorkerClientDriver} object from {@link SharedWorkerServer.addClient SharedWorkerServer.addClient()},
 * then specify {@link IProtocol listener} with the
 * {@link SharedWorkerClientDriver.listen SharedWorkerClientDriver.listen()} method.
 *
 * #### Why SharedWorker be a server?
 * SharedWorker, it allows only an instance (process) to be created whether the SharedWorker is declared in a browser
 * or multiple browsers. To integrate them, messages are being sent and received. Doesn't it seem like a relationship
 * between a server and clients? Thus, Samchon Framework consider the SharedWorker as a server and browsers as
 * clients.
 *
 * The class {@link SharedWorkerCommunicator} is designed make such relationship. From now on, SharedWorker is a
 * {@link SharedWorkerServer server} and {@link SharedWorkerServerConnector browsers} are clients. Integrate the
 * server and clients with this {@link SharedWorkerCommunicator}.
 *
 * #### [Inherited] {@link IClientDriver}
 * @copydoc IClientDriver
 */
var SharedWorkerClientDriver = /** @class */ (function (_super) {
    __extends(SharedWorkerClientDriver, _super);
    /* ---------------------------------------------------------
        CONSTRUCTORS
    --------------------------------------------------------- */
    /**
     * Construct from a MessagePort object.
     */
    function SharedWorkerClientDriver(port) {
        var _this = _super.call(this) || this;
        _this.port_ = port;
        _this.connected_ = true;
        _this.listening_ = false;
        return _this;
    }
    /**
     * @inheritdoc
     */
    SharedWorkerClientDriver.prototype.listen = function (listener) {
        this.listener_ = listener;
        if (this.listening_ == true)
            return;
        this.listening_ = true;
        this.port_.onmessage = this._Handle_message.bind(this);
    };
    return SharedWorkerClientDriver;
}(SharedWorkerCommunicator_1.SharedWorkerCommunicator));
exports.SharedWorkerClientDriver = SharedWorkerClientDriver;
//# sourceMappingURL=SharedWorkerClientDriver.js.map