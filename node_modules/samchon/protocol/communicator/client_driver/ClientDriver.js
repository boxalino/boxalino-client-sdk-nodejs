"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Communicator_1 = require("../communicator/Communicator");
/**
 * Communicator with remote client.
 *
 * {@link ClientDriver} is a class taking full charge of network communication with remote client who follows Samchon
 * Framework's own protocol. This {@link ClientDriver} object is always created by {@link Server} class. When you got
 * this {@link ClientDriver} object from the {@link Server.addClient Server.addClient()}, then specify
 * {@link IProtocol listener} with the {@link ClientDriver.listen ClientDriver.listen()} method.
 *
 * #### [Inherited] {@link IClientDriver}
 * @copydoc IClientDriver
 */
var ClientDriver = /** @class */ (function (_super) {
    __extends(ClientDriver, _super);
    /**
     * Construct from a socket.
     */
    function ClientDriver(socket) {
        var _this = _super.call(this) || this;
        _this["socket_"] = socket;
        _this.connected_ = true;
        return _this;
    }
    /**
     * @inheritdoc
     */
    ClientDriver.prototype.listen = function (listener) {
        this.listener_ = listener;
        this._Start_listen();
    };
    return ClientDriver;
}(Communicator_1.Communicator));
exports.ClientDriver = ClientDriver;
//# sourceMappingURL=ClientDriver.js.map