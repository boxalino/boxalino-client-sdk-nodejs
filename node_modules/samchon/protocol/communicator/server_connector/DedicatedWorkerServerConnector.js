"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var DedicatedWorkerCommunicator_1 = require("../communicator/DedicatedWorkerCommunicator");
/**
 * A server connector for DedicatedWorker.
 *
 * {@link DedicatedWorkerServerConnector} is a class connecting to SharedWorker and taking full charge of network
 * communication with the SharedWorker. Create an {@link DedicatedWorkerServer} instance from the
 * {@IProtocol listener} and call the {@link connect connect()} method.
 *
 * #### Why DedicatedWorker be a server?
 * In JavaScript environment, there's no way to implement multi-threading function. Instead, JavaScript supports the
 * **Worker**, creating a new process. However, the **Worker** does not shares memory addresses. To integrate the
 * **Worker** with its master, only communication with string or binary data is allowed. Doesn't it seem like a network
 * communication? Furthermore, there's not any difference between the worker communication and network communication.
 * It's the reason why Samchon Framework considers the **Worker** as a network node.
 *
 * The class {@link DedicatedWorkerCommunicator} is designed make such relationship. From now on, DedicatedWorker is a
 * {@link DedicatedWorkerServer server} and {@link DedicatedWorkerServerConnector browser} is a client. Integrate the
 * server and clients with this {@link DedicatedWorkerCommunicator}.
 *
 * #### [Inherited] {@link IServerConnector}
 * @copydoc IServerConnector
 */
var DedicatedWorkerServerConnector = /** @class */ (function (_super) {
    __extends(DedicatedWorkerServerConnector, _super);
    /* ---------------------------------------------------------
        CONSTRUCTORS
    --------------------------------------------------------- */
    /**
     * Construct from *listener*.
     *
     * @param listener A listener object to listen replied message from newly connected client in
     *				   {@link IProtocol.replyData replyData()} as an {@link Invoke} object.
        */
    function DedicatedWorkerServerConnector(listener) {
        var _this = _super.call(this, listener) || this;
        _this.worker_ = null;
        return _this;
    }
    /**
     * @inheritdoc
     */
    DedicatedWorkerServerConnector.prototype.connect = function (jsFile) {
        // CONSTRUCT WORKER AND START LISTENING
        this.worker_ = new Worker(jsFile);
        this.worker_.onmessage = this._Handle_message.bind(this);
        // NOTIFY THE CONNECTION
        this.connected_ = true;
        if (this.onConnect != null)
            this.onConnect();
    };
    /**
     * @inheritdoc
     */
    DedicatedWorkerServerConnector.prototype.close = function () {
        this.worker_.terminate();
        if (this.onClose != null)
            this.onClose();
    };
    /* ---------------------------------------------------------
        INVOKE MESSAGE CHAIN
    --------------------------------------------------------- */
    /**
     * @inheritdoc
     */
    DedicatedWorkerServerConnector.prototype.sendData = function (invoke) {
        this.worker_.postMessage(invoke.toXML().toString());
        for (var i = 0; i < invoke.size(); i++)
            if (invoke.at(i).getType() == "ByteArray")
                this.worker_.postMessage(invoke.at(i).getValue());
    };
    return DedicatedWorkerServerConnector;
}(DedicatedWorkerCommunicator_1.DedicatedWorkerCommunicator));
exports.DedicatedWorkerServerConnector = DedicatedWorkerServerConnector;
//# sourceMappingURL=DedicatedWorkerServerConnector.js.map