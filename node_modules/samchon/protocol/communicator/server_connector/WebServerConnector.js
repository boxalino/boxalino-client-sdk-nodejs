"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ws = require("websocket");
var std = require("tstl");
var WebCommunicator_1 = require("../communicator/WebCommunicator");
/**
 * A server connector for web-socket protocol.
 *
 * {@link WebServerConnector} is a class connecting to remote server who follows Web-socket protocol and taking full
 * charge of network communication with the remote server. Create an {@link WebServerConnector} instance from the
 * {@IProtocol listener} and call the {@link connect connect()} method.
 *
 * #### [Inherited] {@link IServerConnector}
 * @copydoc IServerConnector
 */
var WebServerConnector = /** @class */ (function (_super) {
    __extends(WebServerConnector, _super);
    /* ----------------------------------------------------
        CONSTRUCTORS
    ---------------------------------------------------- */
    /**
     * Construct from *listener*.
     *
     * @param listener A listener object to listen replied message from newly connected client in
     *				   {@link IProtocol.replyData replyData()} as an {@link Invoke} object.
        */
    function WebServerConnector(listener) {
        var _this = _super.call(this, listener) || this;
        _this.browser_socket_ = null;
        _this.node_client_ = null;
        _this.connected_ = false;
        _this.onConnect = null;
        return _this;
    }
    /**
     * Connect to a web server.
     *
     * Connects to a server with specified *host* address, *port* number and *path*. After the connection has
     * succeeded, callback function {@link onConnect} is called. Listening data from the connected server also begins.
     * Replied messages from the connected server will be converted to {@link Invoke} classes and will be shifted to
     * the {@link WebCommunicator.listener listener}'s {@link IProtocol.replyData replyData()} method.
     *
     * If the connection fails immediately, either an event is dispatched or an exception is thrown: an error
     * event is dispatched if a host was specified, and an exception is thrown if no host was specified. Otherwise,
     * the status of the connection is reported by an event. If the socket is already connected, the existing
     * connection is closed first.
     *
     * @param ip The name or IP address of the host to connect to.
     *			 If no host is specified, the host that is contacted is the host where the calling file resides.
        *			 If you do not specify a host, use an event listener to determine whether the connection was
        *			 successful.
        * @param port The port number to connect to.
        * @param path Path of service which you want.
        */
    WebServerConnector.prototype.connect = function (ip, port, path) {
        if (path === void 0) { path = "/"; }
        // COMPOSITE FULL-ADDRESS
        var address;
        if (ip.indexOf("ws://") == -1)
            if (ip.indexOf("://") != -1)
                throw "only websocket is possible";
            else
                ip = "ws://" + ip;
        if (path.length != 0 && path.charAt(0) != "/")
            path = "/" + path;
        address = ip + ":" + port + path;
        // CONNECTION BRANCHES
        if (std.is_node() == true) {
            this.node_client_ = new ws.client();
            this.node_client_.on("connect", this._Handle_node_connect.bind(this));
            this.node_client_.connect(address);
        }
        else {
            this.browser_socket_ = new WebSocket(address);
            this.browser_socket_.onopen = this._Handle_browser_connect.bind(this);
            this.browser_socket_.onerror = this._Handle_close.bind(this);
            this.browser_socket_.onclose = this._Handle_close.bind(this);
            this.browser_socket_.onmessage = this._Handle_browser_message.bind(this);
        }
    };
    /**
     * @inheritdoc
     */
    WebServerConnector.prototype.close = function () {
        if (std.is_node() == true)
            _super.prototype.close.call(this);
        else
            this.browser_socket_.close();
    };
    /* ----------------------------------------------------
        IPROTOCOL'S METHOD
    ---------------------------------------------------- */
    /**
     * @inheritdoc
     */
    WebServerConnector.prototype.sendData = function (invoke) {
        if (this.browser_socket_ != null) {
            this.browser_socket_.send(invoke.toXML().toString());
            for (var i = 0; i < invoke.size(); i++)
                if (invoke.at(i).getType() == "ByteArray")
                    this.browser_socket_.send(invoke.at(i).getValue());
        }
        else {
            _super.prototype.sendData.call(this, invoke);
        }
    };
    /**
     * @hidden
     */
    WebServerConnector.prototype._Handle_browser_connect = function (event) {
        this.connected_ = true;
        if (this.onConnect != null)
            this.onConnect();
    };
    /**
     * @hidden
     */
    WebServerConnector.prototype._Handle_browser_message = function (event) {
        if (this._Is_binary_invoke() == false)
            this._Handle_string(event.data);
        else
            this._Handle_binary(event.data);
    };
    /**
     * @hidden
     */
    WebServerConnector.prototype._Handle_node_connect = function (connection) {
        this.connected_ = true;
        this["connection_"] = connection;
        this["connection_"].on("message", this["_Handle_message"].bind(this));
        this["connection_"].on("close", this._Handle_close.bind(this));
        this["connection_"].on("error", this._Handle_close.bind(this));
        if (this.onConnect != null)
            this.onConnect();
    };
    return WebServerConnector;
}(WebCommunicator_1.WebCommunicator));
exports.WebServerConnector = WebServerConnector;
//# sourceMappingURL=WebServerConnector.js.map