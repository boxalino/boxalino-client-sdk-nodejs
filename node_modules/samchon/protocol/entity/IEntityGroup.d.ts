import * as std from "tstl";
import { IEntity } from "./IEntity";
import { XML } from "sxml";
/**
 * A container of entity, and it's a type of entity, too.
 *
 * ![Class Diagram](http://samchon.github.io/framework/images/design/ts_class_diagram/protocol_message_protocol.png)
 *
 * @handbook  [Protocol - Standard Message](https://github.com/samchon/framework/wiki/TypeScript-Protocol-Standard_Message)
 * @author Jeongho Nam <http://samchon.org>
 */
export interface IEntityGroup<T extends IEntity, SourceT extends std.base.Container<T, SourceT, IteratorT, ReverseT>, IteratorT extends std.base.Iterator<T, SourceT, IteratorT, ReverseT>, ReverseT extends std.base.ReverseIterator<T, SourceT, IteratorT, ReverseT>> extends IEntity, std.base.Container<T, SourceT, IteratorT, ReverseT> {
    /**
     * Construct data of the Entity from an XML object.
     *
     * Constructs the EntityArray's own member variables only from the input XML object.
     *
     * Do not consider about constructing children Entity objects' data in EntityArray::construct().
     * Those children Entity objects' data will constructed by their own construct() method. Even insertion
     * of XML objects representing children are done by abstract method of EntityArray::toXML().
     *
     * Constructs only data of EntityArray's own.
     */
    construct(xml: XML): void;
    /**
     * Factory method of a child Entity.
     *
     * EntityArray::createChild() is a factory method creating a new child Entity which is belonged
     * to the EntityArray. This method is called by EntityArray::construct(). The children construction
     * methods Entity::construct() will be called by abstract method of the EntityArray::construct().
     *
     * @return A new child Entity belongs to EntityArray.
     */
    createChild(xml: XML): T;
    /**
     * Get iterator to element.
     *
     * Searches the container for an element with a identifier equivalent to *key* and returns an
     * iterator to it if found, otherwise it returns an iterator to {@link end end()}.
     *
     * Two keys are considered equivalent if the container's comparison object returns false reflexively
     * (i.e., no matter the order in which the elements are passed as arguments).
     *
     * Another member functions, {@link has has()} and {@link count count()}, can be used to just check
     * whether a particular *key* exists.
     *
     * @param key Key to be searched for
     * @return An iterator to the element, if an element with specified *key* is found, or
     *		   {@link end end()} otherwise.
        */
    /**
     * Whether have the item or not.
     *
     * Indicates whether a map has an item having the specified identifier.
     *
     * @param key Key value of the element whose mapped value is accessed.
     *
     * @return Whether the map has an item having the specified identifier.
     */
    has(key: any): boolean;
    /**
     * Count elements with a specific key.
     *
     * Searches the container for elements whose key is *key* and returns the number of elements found.
     *
     * @param key Key value to be searched for.
     *
     * @return The number of elements in the container with a *key*.
     */
    count(key: any): number;
    /**
     * Get an element
     *
     * Returns a reference to the mapped value of the element identified with *key*.
     *
     * @param key Key value of the element whose mapped value is accessed.
     *
     * @throw exception out of range
     *
     * @return A reference object of the mapped value (_Ty)
     */
    get(key: any): T;
    /**
     * A tag name of children objects.
     */
    CHILD_TAG(): string;
    /**
     * Get an XML object represents the EntityArray.
     *
     * Archives the EntityArray's own member variables only to the returned XML object.
     *
     * Do not consider about archiving children Entity objects' data in EntityArray::toXML().
     * Those children Entity objects will converted to XML object by their own toXML() method. The
     * insertion of XML objects representing children are done by abstract method of
     * EntityArray::toXML().
     *
     * Archives only data of EntityArray's own.
     */
    toXML(): XML;
}
/**
 * @hidden
 */
export declare namespace IEntityGroup {
    /**
     * @hidden
     */
    function construct<T extends IEntity, SourceT extends std.base.Container<T, SourceT, IteratorT, ReverseT>, IteratorT extends std.base.Iterator<T, SourceT, IteratorT, ReverseT>, ReverseT extends std.base.ReverseIterator<T, SourceT, IteratorT, ReverseT>>(entityGroup: IEntityGroup<T, SourceT, IteratorT, ReverseT>, xml: XML, ...prohibited_names: string[]): void;
    /**
     * @hidden
     */
    function toXML<T extends IEntity, SourceT extends std.base.Container<T, SourceT, IteratorT, ReverseT>, IteratorT extends std.base.Iterator<T, SourceT, IteratorT, ReverseT>, ReverseT extends std.base.ReverseIterator<T, SourceT, IteratorT, ReverseT>>(group: IEntityGroup<T, SourceT, IteratorT, ReverseT>, ...prohibited_names: string[]): XML;
    function has<T extends IEntity, SourceT extends std.base.Container<T, SourceT, IteratorT, ReverseT>, IteratorT extends std.base.Iterator<T, SourceT, IteratorT, ReverseT>, ReverseT extends std.base.ReverseIterator<T, SourceT, IteratorT, ReverseT>>(entityGroup: IEntityGroup<T, SourceT, IteratorT, ReverseT>, key: any): boolean;
    function count<T extends IEntity, SourceT extends std.base.Container<T, SourceT, IteratorT, ReverseT>, IteratorT extends std.base.Iterator<T, SourceT, IteratorT, ReverseT>, ReverseT extends std.base.ReverseIterator<T, SourceT, IteratorT, ReverseT>>(entityGroup: IEntityGroup<T, SourceT, IteratorT, ReverseT>, key: any): number;
    function get<T extends IEntity, SourceT extends std.base.Container<T, SourceT, IteratorT, ReverseT>, IteratorT extends std.base.Iterator<T, SourceT, IteratorT, ReverseT>, ReverseT extends std.base.ReverseIterator<T, SourceT, IteratorT, ReverseT>>(entityGroup: IEntityGroup<T, SourceT, IteratorT, ReverseT>, key: any): T;
}
